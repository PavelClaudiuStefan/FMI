<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html -->
<HTML lang=en xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><HEAD 
xmlns:html="http://www.w3.org/1999/xhtml"><TITLE>XSL Transformations</TITLE>
<META http-equiv=Content-Type content="text/html; charset=ISO-8859-1">
<META content="MSHTML 6.00.2462.0" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#ffffff xmlns:html="http://www.w3.org/1999/xhtml">
<H1>Chapter 17 of the <CITE>XML Bible, Second Edition </CITE>: XSL 
Transformations </H1>
<H2>In This Chapter</H2>
<UL>
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e495">What 
  Is XSL?</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e531">Overview 
  of XSL Transformations</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e1349">XSL 
  Templates</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e1685">Computing 
  the Value of a Node with xsl:value-of</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e2003">Processing 
  Multiple Elements with xsl:for-each</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e2090">Patterns 
  for Matching Nodes</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e3567">XPath 
  Expressions for Selecting Nodes</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e6203">The 
  Default Template Rules</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e6328">Deciding 
  What Output to Include</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e7170">Copying 
  the Context Node with xsl:copy</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e7364">Counting 
  Nodes with xsl:number</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e8030">Sorting 
  Output Elements</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e8275">Modes</A> 

  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e8497">Defining 
  Constants with xsl:variable</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e8598">Named 
  Templates</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e8730">Passing 
  Parameters to Templates</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e8886">Stripping 
  and Preserving White Space</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e9006">Making 
  Choices</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e9189">Merging 
  Multiple Style Sheets</A> 
  <LI><A 
  href="http://www.ibiblio.org/xml/books/bible2/chapters/ch17.html#d1e9432">Output 
  Methods</A> </LI></UL>
<P class=GX>The Extensible Stylesheet Language (XSL) includes both a 
transformation language and a formatting language. Each of these, naturally 
enough, is an XML application. The transformation language provides elements 
that define rules for how one XML document is transformed into another XML 
document. The transformed XML document may use the markup and DTD of the 
original document, or it may use a completely different set of elements. In 
particular, it may use the elements defined by the second part of XSL, the 
formatting objects. This chapter discusses the transformation language half of 
XSL. </P>
<H2><A name=d1e495>What Is XSL?</A></H2>
<P class=GX>The transformation and formatting halves of XSL can function 
independently of each other. For instance, the transformation language can 
transform an XML document into a well-formed HTML file, and completely ignore 
XSL formatting objects. This is the style of XSL previewed in Chapter 5 and 
emphasized in this chapter. Furthermore, it's not absolutely required that a 
document written in XSL formatting objects be produced by using the 
transformation part of XSL on another XML document. For example, it's easy to 
imagine a converter written in Java that reads TeX or PDF files and translates 
them into XSL formatting objects (though no such converters exist as of early 
2001). </P>
<P class=GX>In essence, XSL is two languages, not one. The first language is a 
transformation language, the second a formatting language. The transformation 
language is useful independent of the formatting language. Its ability to move 
data from one XML representation to another makes it an important component of 
XML-based electronic commerce, electronic data interchange, metadata exchange, 
and any application that needs to convert between different XML representations 
of the same data. These uses are also united by their lack of concern with 
rendering data on a display for humans to read. They are purely about moving 
data from one computer system or program to another. </P>
<P class=GX>Consequently, many early implementations of XSL focus exclusively on 
the transformation part and ignore the formatting objects. These are incomplete 
implementations, but nonetheless useful. Not all data must ultimately be 
rendered on a computer monitor or printed on paper. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Cross-Reference</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Chapter 
18<SPAN class=italic> </SPAN>discusses the XSL formatting language. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans; TEXT-ALIGN: center">A 
Word of Caution about XSL</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">XSL 
is still under development. The language has changed radically in the past, and 
will almost certainly change again in the future. This chapter is based on the 
November 16, 1999 XSLT 1.0 Recommendation. Because XSLT is now an official 
Recommendation of the World Wide Web Consortium (W3C), I'm hopeful that any 
changes that do occur will simply add to the existing syntax without 
invalidating style sheets that adhere to the 1.0 spec. Indeed the W3C has just 
begun work on XSLT 1.1 and 2.0, and it does seem likely that all legal XSLT 1.0 
documents will still be legal XSLT 1.1 and 2.0 documents. </P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Not 
all software has caught up to the 1.0 Recommendation, however. In particular, 
Version 5.5 and earlier of Internet Explorer only implement a very old working 
draft of XSLT that looks almost nothing like the finished standard. You should 
not expect most of the examples in this chapter to work with IE, even after 
substantial tweaking. Conversely, the language that IE does implement is not 
XSLT; and any book or person that tells you otherwise is telling you an untruth. 
Both Microsoft's live presentations and the written documentation it posts on 
its Web site are notorious for teaching nonstandard Microsoft versions of XSLT 
(and other languages) without clearly distinguishing which parts are real XSLT 
and which are Microsoft extensions to (some would say perversions of) standard 
XSLT. </P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">In 
November 2000 Microsoft released MSXML 3.0, an XML parser/XSLT processor for IE 
that does come much closer to supporting XSLT 1.0. You can download it from 
<CODE>http://msdn.microsoft.com/xml/general/xmlparser.asp</CODE>. However, there 
are still some bugs and areas where Microsoft did not follow the specification, 
so this is not quite a complete implementation of XSLT 1.0. More importantly, 
MSXML 3.0 is not bundled with IE5.5; and even if you install it, it does not 
automatically replace the earlier, non-standard-compliant version of MSXML that 
is bundled. To replace the old version, you have to download and run a separate 
program called xmlinst.exe, which you can get from the same page where you found 
MSXML 3.0. </P>
<H2><A name=d1e531>Overview of XSL Transformations</A></H2>
<P class=GX>In an XSL transformation, an XSLT processor reads both an XML 
document and an XSLT style sheet. Based on the instructions the processor finds 
in the XSLT style sheet, it outputs a new XML document or fragment thereof. 
There's also special support for outputting HTML. With some effort most XSLT 
processors can also be made to output essentially arbitrary text, though XSLT is 
designed primarily for XML-to-XML and XML-to-HTML transformations. </P>
<H3>Trees</H3>
<P class=GX>As you learned in Chapter 6, every well-formed XML document is a 
tree. A tree is a data structure composed of connected nodes beginning with a 
top node called the root. The root is connected to its child nodes, each of 
which is connected to zero or more children of its own, and so forth. Nodes that 
have no children of their own are called <SPAN class=italic>leaves</SPAN>. A 
diagram of a tree looks much like a genealogical descendant chart that lists the 
descendants of a single ancestor. The most useful property of a tree is that 
each node and its children also form a tree. Thus, a tree is a hierarchical 
structure of trees in which each tree is built out of smaller trees. </P>
<P class=GX>For the purposes of XSLT, elements, attributes, namespaces, 
processing instructions, and comments are counted as nodes. Furthermore, the 
root of the document must be distinguished from the root element. Thus, XSLT 
processors model an XML document as a tree that contains seven kinds of nodes: 
</P>
<UL>
  <LI>The root 
  <LI>Elements 
  <LI>Text 
  <LI>Attributes 
  <LI>Namespaces 
  <LI>Processing instructions 
  <LI>Comments </LI></UL>
<P class=GX>The Document Type Definition (DTD) and document type declaration are 
specifically not included in this tree. However, a DTD may add default attribute 
values to some elements, which then become additional attribute nodes in the 
tree. </P>
<P class=GX>For example, consider the XML document in Listing 17-1. This shows 
part of the periodic table of the elements. I’ll be using this as an example in 
this chapter. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">On 
the CD-ROM</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">The 
complete periodic table appears on the CD-ROM in the file allelements.xml in the 
examples/periodic_table directory.</P>
<P class=GX>The root <CODE>PERIODIC_TABLE</CODE> element contains 
<CODE>ATOM</CODE> child elements. Each <CODE>ATOM</CODE> element contains 
several child elements providing the atomic number, atomic weight, symbol, 
boiling point, and so forth. A <CODE>UNITS</CODE> attribute specifies the units 
for those elements that have units. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Note</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans"><CODE>ELEMENT</CODE> 
would be a more appropriate name here than <CODE>ATOM</CODE>. However, writing 
about <CODE>ELEMENT</CODE> elements and trying to distinguish between chemical 
elements and XML elements might create confusion. Thus, at least for the 
purposes of this chapter, <CODE>ATOM</CODE> seemed like the more legible option. 
</P>
<P style="FONT-WEIGHT: bold">Listing 17-1: An XML periodic table with two atoms: 
hydrogen and helium </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xml" href="17-2.xsl"?&gt;
&lt;PERIODIC_TABLE&gt;
  &lt;ATOM STATE="GAS"&gt;
    &lt;NAME&gt;Hydrogen&lt;/NAME&gt;
    &lt;SYMBOL&gt;H&lt;/SYMBOL&gt;
    &lt;ATOMIC_NUMBER&gt;1&lt;/ATOMIC_NUMBER&gt;
    &lt;ATOMIC_WEIGHT&gt;1.00794&lt;/ATOMIC_WEIGHT&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;20.28&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;13.81&lt;/MELTING_POINT&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
  &lt;/ATOM&gt;
  &lt;ATOM STATE="GAS"&gt;
    &lt;NAME&gt;Helium&lt;/NAME&gt;
    &lt;SYMBOL&gt;He&lt;/SYMBOL&gt;
    &lt;ATOMIC_NUMBER&gt;2&lt;/ATOMIC_NUMBER&gt;
    &lt;ATOMIC_WEIGHT&gt;4.0026&lt;/ATOMIC_WEIGHT&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;4.216&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;0.95&lt;/MELTING_POINT&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;&lt;!-- At 300K --&gt;
      0.0001785
    &lt;/DENSITY&gt;
  &lt;/ATOM&gt;
&lt;/PERIODIC_TABLE&gt;
</CODE></PRE>
<P class=GX>Figure 17-1 displays a tree diagram of this document. It begins at 
the top with the root node (not the same as the root element!) which contains 
two child nodes, the <CODE>xml-stylesheet</CODE> processing instruction and the 
root element <CODE>PERIODIC_TABLE</CODE>. (The XML declaration is not visible to 
the XSLT processor and is not included in the tree the XSLT processor operates 
on.) The <CODE>PERIODIC_TABLE</CODE> element contains two child nodes, both 
<CODE>ATOM</CODE> elements. Each <CODE>ATOM</CODE> element has an attribute node 
for its <CODE>STATE</CODE> attribute, and a variety of child element nodes. Each 
child element contains a node for its contents, as well as nodes for any 
attributes, comments and processing instructions it possesses. Notice in 
particular that many nodes are something other than elements. There are nodes 
for text, attributes, comments, namespaces and processing instructions. Unlike 
CSS, XSL is not limited to working only with whole elements. It has a much more 
granular view of a document that enables you to base styles on comments, 
attributes, processing instructions, element content, and more. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Note</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Like 
the XML declaration, an internal DTD subset or DOCTYPE declaration is not part 
of the tree. However, it may have the effect of adding attribute nodes to some 
elements through <CODE>&lt;!ATTLIST&gt;</CODE> declarations that use 
<CODE>#FIXED</CODE> or default attribute values. </P>
<DIV align=center><IMG height=118 alt="Image: 17/picture1.jpg" 
src="XSL Transformations_files/picture1.jpg" width=299></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-1: Listing 17-1 as a tree diagram </P>
<P class=GX>XSLT operates by transforming one XML tree into another XML tree. 
More precisely, an XSLT processor accepts as input a tree represented as an XML 
document and produces as output a new tree, also represented as an XML document. 
Consequently, the transformation part of XSL is also called the tree 
construction part. The XSL transformation language contains operators for 
selecting nodes from the tree, reordering the nodes, and outputting nodes. If 
one of these nodes is an element node, then it may be an entire tree itself. 
Remember that all these operators, both for input and output, are designed for 
operation on a tree. </P>
<P class=GX>The input must be an XML document. You cannot use XSLT to transform 
from non-XML formats such as PDF, TeX, Microsoft Word, PostScript, MIDI, or 
others. HTML and SGML are borderline cases because they're so close to XML. XSLT 
can work with HTML and SGML documents that satisfy XML's well-formedness rules. 
However, XSLT cannot handle the wide variety of non-well-formed HTML and SGML 
that you encounter on most Web sites and document production systems. XSLT is 
not a general-purpose regular expression language for transforming arbitrary 
data. </P>
<P class=GX>Most of the time the output of an XSLT transformation is also an XML 
document. However, it can also be a result tree fragment that could be used as 
an external parsed entity in another XML document. (That is, it would be a 
well-formed XML document if it were enclosed in a single root element.) In other 
words, the output may not necessarily be a well-formed XML document, but it will 
at least be a plausible part of a well-formed XML document. An XSLT 
transformation cannot output text that is malformed XML such as </P><PRE><CODE>&lt;B&gt;&lt;I&gt;Tag Mismatch!&lt;/B&gt;&lt;/I&gt;
</CODE></PRE>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Tip</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">The 
<CODE>xsl:output</CODE> element and <CODE>disable-output-escaping</CODE> 
attribute discussed below loosen this restriction somewhat. </P>
<P class=GX>Most XSLT processors also support output as HTML and/or raw text, 
although the standard does not require them to do so. To some extent this allows 
you to transform to non-XML formats like TeX, RTF, or PostScript. However XSLT 
is not designed to make these transformations easy. It is designed for 
XML-to-XML transformations. If you need a non-XML output format, it will 
probably be easier to use XSLT to transform the XML to an intermediate format 
like TeXML (<CODE>http://www.alphaworks.ibm.com/tech/texml</CODE>), and then use 
additional, non-XSLT software to transform that into the format you want. </P>
<H3>XSLT style sheet documents</H3>
<P class=GX>An XSLT document contains template rules. A template rule has a 
pattern specifying the nodes it matches and a template to be instantiated and 
output when the pattern is matched. When an XSLT processor transforms an XML 
document using an XSL style sheet, it walks the XML document tree, looking at 
each node in turn. As each node in the XML document is read, the processor 
compares it with the pattern of each template rule in the style sheet. When the 
processor finds a node that matches a template rule's pattern, it outputs the 
rule's template. This template generally includes some markup, some new data, 
and some data copied out of the source XML document. </P>
<P class=GX>XSLT uses XML to describe these rules, templates, and patterns. The 
root element of the XSLT document is either a <CODE>stylesheet</CODE> or a 
<CODE>transform</CODE> element in the 
<CODE>http://www.w3.org/1999/XSL/Transform</CODE> namespace. By convention this 
namespace is mapped to the <CODE>xsl</CODE> prefix, but you're free to pick 
another prefix if you prefer. In this chapter, I always use the <CODE>xsl</CODE> 
prefix. From this point forward it should be understood that the prefix 
<CODE>xsl</CODE> is mapped to the 
<CODE>http://www.w3.org/1999/XSL/Transform</CODE> namespace. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Tip</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">If 
you get the namespace URI wrong, either by using a URI from an older draft of 
the specification, such as <CODE>http://www.w3.org/TR/WD-xsl</CODE>, or simply 
by making a typo in the normal URI, the XSLT processor will output the style 
sheet document itself instead of the transformed input document. This is the 
result of the interaction between several obscure sections of the XSLT 1.0 
specification. The details aren’t important. What is important is that this very 
unusual behavior looks very much like a bug in the processor if you aren’t 
familiar with it. If you are familiar with it, fixing it is trivial; just 
correct the namespace URI to <CODE>http://www.w3.org/1999/XSL/Transform</CODE>. 
</P>
<P class=GX>Each template rule is an <CODE>xsl:template</CODE> element. The 
pattern of the rule is placed in the <CODE>match</CODE> attribute of the 
<CODE>xsl:template</CODE> element. The output template is the content of the 
<CODE>xsl:template</CODE> element. All instructions in the template for doing 
things such as selecting parts of the input tree to include in the output tree 
are performed by one or another XSLT elements. These are identified by the 
<CODE>xsl:</CODE> prefix on the element names. Elements that do not have an 
<CODE>xsl:</CODE> prefix are part of the result tree. </P>
<P class=GX>Listing 17-2 shows a very simple XSLT style sheet with two template 
rules. The first template rule matches the root element 
<CODE>PERIODIC_TABLE</CODE>. It replaces this element with an <CODE>html</CODE> 
element. The contents of the <CODE>html</CODE> element are the results of 
applying the other templates in the document to the contents of the 
<CODE>PERIODIC_TABLE</CODE> element. </P>
<P class=GX>The second template matches <CODE>ATOM</CODE> elements. It replaces 
each <CODE>ATOM</CODE> element in the input document with a <CODE>P</CODE> 
element in the output document. The <CODE>xsl:apply-templates</CODE> rule 
inserts the text of the matched source element into the output document. Thus, 
the contents of a <CODE>P</CODE> element will be the text (but not the markup) 
contained in the corresponding <CODE>ATOM</CODE> element. </P>
<P class=GX>The <CODE>xsl:stylesheet</CODE> root element has two required 
attributes, <CODE>version</CODE> and <CODE>xmlns:xsl</CODE>, each of which must 
have exactly the values shown here (<CODE>1.0</CODE> for <CODE>version</CODE> 
and <CODE>http://www.w3.org/1999/XSL/Transform</CODE> for 
<CODE>xmlns:xsl</CODE>). I'll discuss the exact syntax of all these elements and 
attributes below. </P>
<P style="FONT-WEIGHT: bold">Listing 17-2: An XSLT style sheet for the periodic 
table with two template rules </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;P&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>The <CODE>xsl:transform</CODE> element can be used in place of 
<CODE>xsl:stylesheet</CODE> if you prefer. This is an exact synonym with the 
same syntax, semantics, and attributes. For example, </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:transform version="1.0" 
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;!-- templates go here --&gt;
&lt;/xsl:transform&gt;
</CODE></PRE>
<P class=GX>In this book, I will stick to <CODE>xsl:stylesheet</CODE>. </P>
<H3>Where does the XML transformation happen?</H3>
<P class=GX>There are three primary ways to transform XML documents into other 
formats, such as HTML, with an XSLT style sheet:</P>
<UL>
  <LI>&nbsp;1.&nbsp;The XML document and associated style sheet are both served 
  to the client (Web browser), which then transforms the document as specified 
  by the style sheet and presents it to the user. 
  <LI>&nbsp;2.&nbsp;The server applies an XSLT style sheet to an XML document to 
  transform it to some other format (generally HTML) and sends the transformed 
  document to the client (Web browser). 
  <LI>&nbsp;3.&nbsp;A third program transforms the original XML document into 
  some other format (often HTML) before the document is placed on the server. 
  Both server and client only deal with the transformed document. </LI></UL>
<P class=GX>Each of these three approaches uses different software, although 
they all use the same XML documents and XSLT style sheets. An ordinary Web 
server sending XML documents to Internet Explorer is an example of the first 
approach. A servlet-compatible Web server using the IBM alphaWorks' XML Enabler 
(<CODE>http://www.alphaworks.ibm.com/tech/xmlenabler</CODE>) is an example of 
the second approach. A human using Michael Kay's command line SAXON program 
(<CODE>http://users.iclway.co.uk/mhkay/saxon/</CODE>) to transform XML documents 
to HTML documents, then placing the HTML documents on a Web server is an example 
of the third approach. However, these all use (at least in theory) the same XSLT 
language. </P>
<P class=GX>In this chapter, I emphasize the third approach, primarily because 
at the time of this writing, specialized converter programs such as Michael 
Kay's SAXON and the XML Apache Project's Xalan 
(<CODE>http://xml.apache.org/xalan/</CODE>) provide the most complete and 
accurate implementations of the XSLT specification. Furthermore, this approach 
offers the broadest compatibility with legacy Web browsers and servers, whereas 
the first approach requires a more recent browser than most users use, and the 
second approach requires special Web server software. In practice, though, 
requiring a different server is not nearly as onerous as requiring a particular 
client. You, yourself, can install your own special server software; but you 
cannot rely on your visitors to install particular client software. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">On 
the CD-ROM</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Xalan 
is on the CD-ROM in the directory utilities/xalan. SAXON is on the CD-ROM in the 
directory utilities/saxon.</P>
<H3>How to use Xalan</H3>
<P class=GX>Xalan is a Java 1.1 character mode application. To use it, you'll 
need a Java 1.1-compatible virtual machine such as Sun's Java Development Kit 
(JDK), or Java Runtime Environment (JRE), Apple's Macintosh Runtime for Java 2.2 
(MRJ), or Microsoft's virtual machine. You'll need to set your 
<CODE>CLASSPATH</CODE> environment variable to include both the xalan.jar and 
xerces.jar files (both included in the Xalan distribution). On Unix/Linux you 
can set this in your .cshrc file if you use csh or tcsh or in your .profile file 
if you use sh, ksh or bash. On Windows 95/98 you can set it in AUTOEXEC.BAT. In 
Windows NT/2000, set it with the System Control Panel Environment tab. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Tip</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">If 
you're using the JRE 1.2 or later, you can just put the xalan.jar and xerces.jar 
files in your jre/lib/ext directory instead of mucking around with the 
<CODE>CLASSPATH</CODE> environment variable. If you've installed the JDK instead 
of the JRE on Windows, you may have two jre/lib/ext directories, one somewhere 
like C:\jdk1.3\jre\lib\ext and the other somewhere like C:\Program 
Files\Javasoft\jre\1.3\lib\ext. You need to copy the jar archive into both ext 
directories. Putting one copy in one directory and an alias into the other 
directory does not work. You must place complete, actual copies into each ext 
directory. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Note</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Although 
I primarily use Xalan in this chapter, the examples should work with SAXON or 
any other XSLT processor that implements the November 16, 1999 XSLT 1.0 
recommendation. </P>
<P class=GX>The Java class containing the main method for Xalan is 
<CODE>org.apache.xalan.xslt.Process</CODE>. You can run Xalan by typing the 
following at the shell prompt or in a DOS window: </P><PRE><CODE>C:\&gt; java org.apache.xalan.xslt.Process -in 17-1.xml -xsl 17-2.xsl -out 17-3.html
</CODE></PRE>
<P class=GX>This line runs the <CODE>java</CODE> interpreter on the Java class 
containing the Xalan program's <CODE>main()</CODE> method, 
<CODE>org.apache.xalan.xslt.Process</CODE>. The source XML document following 
the -in flag is 17-1.xml. The XSLT style sheet follows the -xsl flag and is 
17-2.xsl here; and the output HTML file follows the -out argument and is named 
17-3.html. If the -out argument is omitted, the transformed document will be 
printed on the console. If the -xsl argument is omitted, Xalan will attempt to 
use the style sheet named by the <CODE>xml-stylesheet</CODE> processing 
instruction in the prolog of the input XML document. </P>
<P class=GX>Listing 17-2 transforms input documents to well-formed HTML files as 
discussed in Chapter 6. However, you can transform from any XML application to 
any other as long as you can write a style sheet to support the transformation. 
For example, you can imagine a style sheet that transforms from Vector Markup 
Language (VML) documents to Scalable Vector Graphics (SVG) documents: </P><PRE><CODE>% java org.apache.xalan.xslt.Process -in pinktriangle.vml
  -xsl VmlToSVG.xsl -out pinktriangle.svg
</CODE></PRE>
<P class=GX>Most other command line XSLT processors behave similarly, though of 
course they'll have different command line arguments and options. They may prove 
slightly easier to use if they're not written in Java since there won't be any 
need to configure the <CODE>CLASSPATH</CODE>. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Tip</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">If 
you're using Windows, you can use a stand-alone executable version of SAXON 
called Instant SAXON 
(<CODE>http://users.iclway.co.uk/mhkay/saxon/instant.html</CODE>) instead. This 
is a little easier to use because it doesn't require you to mess around with 
<CODE>CLASSPATH</CODE> environment variables. To transform a document with this 
program, simply place the saxon.exe file in your path and type: </P>
<P class=icon-code>C:\&gt; saxon -o 17-3.html 17-1.xml 17-2.xsl</P>
<P class=GX>Listing 17-3 shows the output of running Listing 17-1 through Xalan 
with the XSLT style sheet in Listing 17-2. Notice that Xalan does not attempt to 
clean up the HTML it generates, which has a lot of white space. This is not 
important since ultimately you want to view the file in a Web browser that trims 
white space. Figure 17-2 shows Listing 17-3 loaded into Netscape Navigator 4.6. 
Because Listing 17-3 is standard HTML, you don't need an XML-capable browser to 
view it. </P>
<P style="FONT-WEIGHT: bold">Listing 17-3: The HTML produced by applying the 
style sheet in Listing 17-2 to the XML in Listing 17-1 </P><PRE><CODE>&lt;html&gt;
  &lt;P&gt;
    Hydrogen
    H
    1
    1.00794
    20.28
    13.81
      0.0000899
  &lt;/P&gt;
  &lt;P&gt;
    Helium
    He
    2
    4.0026
    4.216
    0.95
      0.0001785
  &lt;/P&gt;
&lt;/html&gt;
</CODE></PRE>
<DIV align=center><IMG height=173 alt="Image: 17/picture3.jpg" 
src="XSL Transformations_files/picture3.jpg" width=335></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-2: The page produced by applying the 
style sheet in Listing 17-2 to the XML document in Listing 17-1. </P>
<H3>Direct display of XML files with XSLT style sheets</H3>
<P class=GX>Instead of preprocessing the XML file, you can send the client both 
the XML file and the XSLT file that describes how to render it. The client is 
responsible for applying the style sheet to the document and rendering it 
accordingly. This is more work for the client, but places much less load on the 
server. In this case, the XSLT style sheet must transform the document into an 
XML application the client understands. HTML is a likely choice, though in the 
future some browsers may understand XSL formatting objects as well. </P>
<P class=GX>Attaching an XSLT style sheet to an XML document is easy. Simply 
insert an <CODE>xml-stylesheet</CODE> processing instruction in the prolog 
immediately after the XML declaration. This processing instruction should have a 
<CODE>type</CODE> attribute with the value <CODE>text/xml</CODE> and an 
<CODE>href</CODE> attribute whose value is a URL pointing to the style sheet. 
For example: </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xml" href="17-2.xsl"?&gt;
</CODE></PRE>
<P class=GX>This is also how you attach a CSS style sheet to a document. The 
only difference here is that the <CODE>type</CODE> attribute has the value 
<CODE>text/xml</CODE> instead of <CODE>text/css</CODE>. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Note</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">In 
the future the more specific MIME media type <CODE>application/xslt+xml</CODE> 
will be available to distinguish XSLT documents from all other XML documents. 
Once XSLT processors are revised to support this, you will be able to write the 
<CODE>xml-stylesheet</CODE> processing instruction like this instead: </P>
<P class=icon-code>&lt;?xml-stylesheet type="application/xslt+xml" 
href="17-2.xsl"?&gt;</P>
<P class=GX>Internet Explorer 5.0 and 5.5's XSLT support differs from the 
November 16, 1999 recommendation in several ways. First, it expects that XSLT 
elements live in the <CODE>http://www.w3.org/TR/WD-xsl</CODE> namespace instead 
of the <CODE>http://www.w3.org/1999/XSL/Transform</CODE> namespace, although the 
<CODE>xsl</CODE> prefix is still used. Second, it expects the non-standard MIME 
type <CODE>text/xsl</CODE> in the <CODE>xml-stylesheet</CODE> processing 
instruction rather than <CODE>text/xml</CODE>. Finally, it does not implement 
the default rules for elements that match no template. Consequently, you need to 
provide a template for each element in the hierarchy starting from the root 
before trying to view a document in Internet Explorer. Listing 17-4 
demonstrates. The three rules match the root node, the root element 
<CODE>PERIODIC_TABLE</CODE>, and the <CODE>ATOM</CODE> elements in that order. 
Figure 17-3 shows the XML document in Listing 17-1 loaded into Internet Explorer 
5.5 with this style sheet. </P>
<P style="FONT-WEIGHT: bold">Listing 17-4: The style sheet of Listing 17-2 
adjusted to work with Internet Explorer 5.0 and 5.5 </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;!-- This is a non-standard style sheet designed just for
     Internet Explorer. It will not work with any standards
     compliant XSLT processor. --&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/TR/WD-xsl"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;P&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Caution</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Ideally, 
you would use the same XML document both for direct display and for prerendering 
to HTML. Unfortunately, that would require Microsoft to actually support the 
real XSLT specification. Microsoft has repeatedly promised to support this, and 
they have just as repeatedly reneged on those promises. </P>
<DIV align=center><IMG height=178 alt="Image: 17/picture5.jpg" 
src="XSL Transformations_files/picture5.jpg" width=335></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-3: The page produced in Internet Explorer 
5.5 by applying the style sheet in Listing 17-4 to the XML document in Listing 
17-1. </P>
<P class=GX>Internet Explorer also fails to support many other parts of standard 
XSLT, while offering a number of nonstandard extensions. If you've successfully 
installed MSXML3 in replace mode, then IE5 can handle most of XSLT 1.0 including 
the <CODE>http://www.w3.org/1999/XSL/Transform</CODE> namespace. However, even 
this version still has a few bugs, including expecting the text/xsl MIME type 
instead of text/xml. In the rest of this chapter, I use only standard XSLT and 
simply prerender the file in HTML before loading it into a Web browser. If you 
find something in this chapter doesn’t work in Internet Explorer, please 
complain to Microsoft, not to me. </P>
<H2><A name=d1e1349>XSL Templates</A></H2>
<P class=GX>Template rules defined by <CODE>xsl:template</CODE> elements are the 
most important part of an XSLT style sheet. These associate particular output 
with particular input. Each <CODE>xsl:template</CODE> element has a 
<CODE>match</CODE> attribute that specifies which nodes of the input document 
the template is instantiated for. </P>
<P class=GX>The content of the <CODE>xsl:template</CODE> element is the actual 
template to be instantiated. A template may contain both text that will appear 
literally in the output document and XSLT instructions that copy data from the 
input XML document to the result. Because all XSLT instructions are in the 
<CODE>http://www.w3.org/1999/XSL/Transform</CODE> namespace, it's easy to 
distinguish between the elements that are literal data to be copied to the 
output and instructions. For example, here is a template that is applied to the 
root node of the input tree: </P><PRE><CODE>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>When the XSLT processor reads the input document, the first node it 
sees is the root. This rule matches that root node, and tells the XSLT processor 
to emit this text: </P><PRE><CODE>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</CODE></PRE>
<P class=GX>This text is well-formed HTML. Because the XSLT document is itself 
an XML document, its contents — templates included — must be well-formed XML. 
</P>
<P class=GX>If you were to use the above rule, and only the above rule, in an 
XSLT style sheet, the output would be limited to the above six tags. That's 
because no instructions in the rule tell the formatter to move down the tree and 
look for further matches against the templates in the style sheet. </P>
<H3>The xsl:apply-templates element</H3>
<P class=GX>To get beyond the root, you have to tell the formatting engine to 
process the children of the root. In general, to include content in the child 
nodes, you have to recursively process the nodes through the XML document. The 
element that does this is <CODE>xsl:apply-templates</CODE>. By including 
<CODE>xsl:apply-templates</CODE> in the output template, you tell the formatter 
to compare each child element of the matched source element against the 
templates in the style sheet, and, if a match is found, output the template for 
the matched node. The template for the matched node may itself contain 
<CODE>xsl:apply-templates</CODE> elements to search for matches for its 
children. When the formatting engine processes a node, the node is treated as a 
complete tree. This is the advantage of the tree structure. Each part can be 
treated the same way as the whole. For example, Listing 17-5 is an XSLT style 
sheet that uses the <CODE>xsl:apply templates</CODE> element to process the 
child nodes. </P>
<P style="FONT-WEIGHT: bold">Listing 17-5: An XSLT style sheet that recursively 
processes the children of the root </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    An Atom
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>When this style sheet is applied to Listing 17-1, here's what 
happens:</P>
<UL>
  <LI>&nbsp;1.&nbsp;The root node is compared with all template rules in the 
  style sheet. It matches the first one. 
  <LI>&nbsp;2.&nbsp;The <CODE>&lt;html&gt;</CODE> tag is written out. 
  <LI>&nbsp;3.&nbsp;The <CODE>xsl:apply-templates</CODE> element causes the 
  formatting engine to process the child nodes of the root node of the input 
  document. </LI></UL>
<P class=NL2>&nbsp;A.&nbsp;The first child of the root, the 
<CODE>xml-stylesheet</CODE> processing instruction, is compared with the 
template rules. It doesn't match any of them, so no output is generated. </P>
<P class=NL2>&nbsp;B.&nbsp;The second child of the root node of the input 
document, the root element <CODE>PERIODIC_TABLE</CODE>, is compared with the 
template rules. It matches the second template rule. </P>
<P class=NL2>&nbsp;C.&nbsp;The <CODE>&lt;body&gt;</CODE> tag is written out. 
</P>
<P class=NL2>&nbsp;D.&nbsp;The <CODE>xsl:apply-templates</CODE> element in the 
<CODE>body</CODE> element causes the formatting engine to process the child 
nodes of <CODE>PERIODIC_TABLE</CODE>. </P>
<P class=BL2>a.&nbsp;The first child of the <CODE>PERIODIC_TABLE</CODE> element, 
that is the Hydrogen <CODE>ATOM</CODE> element, is compared with the template 
rules. It matches the third template rule. </P>
<P class=BL2>b.&nbsp;The text "An Atom" is output.</P>
<P class=BL2>c.&nbsp;The second child of the <CODE>PERIODIC_TABLE</CODE> 
element, that is the Helium <CODE>ATOM</CODE> element, is compared with the 
template rules. It matches the third template rule. </P>
<P class=BL2>d.&nbsp;The text "An Atom" is output.</P>
<P class=NL2>&nbsp;E.&nbsp;The <CODE>&lt;/body&gt;</CODE> tag is written out. 
</P>
<UL>
  <LI>&nbsp;4.&nbsp;The <CODE>&lt;/html&gt;</CODE> tag is written out. 
  <LI>&nbsp;5.&nbsp;Processing is complete. </LI></UL>
<P class=GX>The end result is:</P><PRE><CODE>&lt;html&gt;
&lt;body&gt;
    An Atom
    An Atom
&lt;/body&gt;
&lt;/html&gt;
</CODE></PRE>
<H3>The select attribute</H3>
<P class=GX>To replace the text "An Atom" with the name of the <CODE>ATOM</CODE> 
element as given by its <CODE>NAME</CODE> child, you need to specify that 
templates should be applied to the <CODE>NAME</CODE> children of the 
<CODE>ATOM</CODE> element. To choose a particular set of children instead of all 
children you supply <CODE>xsl:apply-templates</CODE> with a <CODE>select</CODE> 
attribute designating the children to be selected. For example: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:apply-templates select="NAME"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>select</CODE> attribute uses the same kind of patterns as 
the <CODE>match</CODE> attribute of the <CODE>xsl:template</CODE> element. For 
now, I'll stick to simple names of elements; but in the section on patterns for 
matching and selecting later in this chapter, you'll see many more possibilities 
for both <CODE>select</CODE> and <CODE>match</CODE>. If no <CODE>select</CODE> 
attribute is present, all child element, text, comment, and processing 
instruction nodes are selected. (Attribute and namespace nodes are not 
selected.) </P>
<P class=GX>The result of adding this rule to the style sheet of Listing 17-5 
and applying it to Listing 17-1 is this:</P><PRE><CODE>&lt;html&gt;
&lt;body&gt;
  Hydrogen
  Helium
&lt;/body&gt;
&lt;/html&gt;
</CODE></PRE>
<H2><A name=d1e1685>Computing the Value of a Node with xsl:value-of</A></H2>
<P class=GX>The <CODE>xsl:value-of</CODE> element computes the value of 
something (most of the time, though not always, something in the input document) 
and copies it into the output document. The <CODE>select</CODE> attribute of the 
<CODE>xsl:value-of</CODE> element specifies exactly which something's value is 
being computed. </P>
<P class=GX>For example, suppose you want to replace the literal text <CODE>An 
Atom</CODE> with the name of the <CODE>ATOM</CODE> element as given by the 
contents of its <CODE>NAME</CODE> child. You can replace <CODE>An Atom</CODE> 
with <CODE>&lt;xsl:value-of select="NAME"/&gt;</CODE> like this: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:value-of select="NAME"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Then, when you apply the style sheet to Listing 17-1, this text is 
generated:</P><PRE><CODE>&lt;html&gt;
&lt;body&gt;
  Hydrogen
  Helium
&lt;/body&gt;
&lt;/html&gt;
</CODE></PRE>
<P class=GX>The item whose value is selected, the <CODE>NAME</CODE> element in 
this example, is relative to the current node. The current node is the item 
matched by the template, the particular <CODE>ATOM</CODE> element in this 
example. Thus, when the Hydrogen <CODE>ATOM</CODE> is matched by 
<CODE>&lt;xsl:template match="ATOM"&gt;</CODE>, the Hydrogen <CODE>ATOM</CODE>'s 
<CODE>NAME</CODE> is selected by <CODE>xsl:value-of</CODE>. When the Helium 
<CODE>ATOM</CODE> is matched by <CODE>&lt;xsl:template match="ATOM"&gt;</CODE>, 
the Helium <CODE>ATOM</CODE>'s <CODE>NAME</CODE> is selected by 
<CODE>xsl:value-of</CODE>. </P>
<P class=GX>The value of a node is always a string, possibly an empty string. 
The exact contents of this string depend on the type of the node. The most 
common type of node is element, and the value of an element node is particularly 
simple. It's the concatenation of all the character data (but not markup!) 
between the element's start tag and end tag. For example, the first 
<CODE>ATOM</CODE> element in Listing 17-1 is as follows: </P><PRE><CODE>  &lt;ATOM STATE="GAS"&gt;
    &lt;NAME&gt;Hydrogen&lt;/NAME&gt;
    &lt;SYMBOL&gt;H&lt;/SYMBOL&gt;
    &lt;ATOMIC_NUMBER&gt;1&lt;/ATOMIC_NUMBER&gt;
    &lt;ATOMIC_WEIGHT&gt;1.00794&lt;/ATOMIC_WEIGHT&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;20.28&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;13.81&lt;/MELTING_POINT&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
  &lt;/ATOM&gt;
</CODE></PRE>
<P class=GX>The value of this element is shown below:</P><PRE><CODE>  Hydrogen
  H
  1
  1.00794
  1
  20.28
  13.81
    0.0000899
</CODE></PRE>
<P class=GX>I calculated this value by stripping out all the tags and comments. 
Everything else including white space was left intact. The values of the other 
six node types are calculated similarly, mostly in obvious ways. Table 17-1 
summarizes. </P>
<P 
style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans; TEXT-ALIGN: center">Table 
17-1: Values of Nodes </P>
<TABLE summary="(unspecified contents)" border=1>
  <COLGROUP>
  <COL width=112>
  <COL width=324></COLGROUP>
  <TBODY>
  <TR>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Node 
      Type: </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Value: 
      </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Root</P></TD>
    <TD vAlign=top>
      <P class=TX>The value of the root element</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Element</P></TD>
    <TD vAlign=top>
      <P class=TX>The concatenation of all parsed character data contained in 
      the element, including character data in any of the descendants of the 
      element </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Text</P></TD>
    <TD vAlign=top>
      <P class=TX>The text of the node; essentially the node itself</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Attribute</P></TD>
    <TD vAlign=top>
      <P class=TX>The normalized attribute value as specified by Section 3.3.3 
      of the XML 1.0 recommendation; basically the attribute value after 
      entities are resolved and leading and trailing white space is stripped; 
      does not include the name of the attribute, the equals sign, or the 
      quotation marks </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Namespace</P></TD>
    <TD vAlign=top>
      <P class=TX>The URI of the namespace</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Processing instruction</P></TD>
    <TD vAlign=top>
      <P class=TX>The data in the processing instruction; does not include the 
      processing instruction , <CODE>&lt;?</CODE> or 
<CODE>?&gt;</CODE></P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>Comment</P></TD>
    <TD vAlign=top>
      <P class=TX>The text of the comment, <CODE>&lt;!--</CODE> and 
      <CODE>--&gt;</CODE> not included </P></TD></TR></TBODY></TABLE>
<H2><A name=d1e2003>Processing Multiple Elements with xsl:for-each</A></H2>
<P class=GX>The <CODE>xsl:value-of</CODE> element should only be used in 
contexts where it is obvious which node's value is being taken. If there are 
multiple possible items that could be selected, then only the first one will be 
chosen. For instance, this is a poor rule because a typical 
<CODE>PERIODIC_TABLE</CODE> element contains more than one <CODE>ATOM</CODE>: 
</P><PRE><CODE>&lt;xsl:template match="PERIODIC_TABLE"&gt;
  &lt;xsl:value-of select="ATOM"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>There are two ways of processing multiple elements in turn. The 
first method you've already seen. Simply use <CODE>xsl:apply-templates</CODE> 
with a <CODE>select</CODE> attribute that chooses the particular elements that 
you want to include, like this: </P><PRE><CODE>  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;xsl:apply-templates select="ATOM"/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>select="."</CODE> in the second template tells the 
formatter to take the value of the matched element, <CODE>ATOM</CODE> in this 
example. </P>
<P class=GX>The second option is <CODE>xsl:for-each</CODE>. The 
<CODE>xsl:for-each</CODE> element processes each element chosen by its 
<CODE>select</CODE> attribute in turn. However, no additional template is 
required. For example: </P><PRE><CODE>&lt;xsl:template match="PERIODIC_TABLE"&gt;
  &lt;xsl:for-each select="ATOM"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H2><A name=d1e2090>Patterns for Matching Nodes</A></H2>
<P class=GX>The <CODE>match</CODE> attribute of the <CODE>xsl:template</CODE> 
element supports a complex syntax that allows you to express exactly which nodes 
you do and do not want to match. The <CODE>select</CODE> attribute of 
<CODE>xsl:apply-templates</CODE>, <CODE>xsl:value-of</CODE>, 
<CODE>xsl:for-each</CODE>, <CODE>xsl:copy-of</CODE>, and <CODE>xsl:sort</CODE> 
supports an even more powerful superset of this syntax called Xpath that allows 
you to express exactly which nodes you do and do not want to select. Various 
patterns for matching and selecting nodes are discussed below. </P>
<H3>Matching the root node</H3>
<P class=GX>In order that the output document be well-formed, the first thing 
output from an XSL transformation should be the output document's root element. 
Consequently, XSLT style sheets generally start with a rule that applies to the 
root node. To specify the root node in a rule, you give its <CODE>match</CODE> 
attribute the value <CODE>"/"</CODE>. For example: </P><PRE><CODE>&lt;xsl:template match="/"&gt;
  &lt;DOCUMENT&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/DOCUMENT&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This rule applies to the root node and only the root node of the 
input tree. When the root node is read, the tag <CODE>&lt;DOCUMENT&gt;</CODE> is 
output, the children of the root node are processed, then the 
<CODE>&lt;/DOCUMENT&gt;</CODE> tag is output. This rule overrides the default 
rule for the root node. Listing 17-6 shows a style sheet with a single rule that 
applies to the root node. </P>
<P style="FONT-WEIGHT: bold">Listing 17-6: An XSLT style sheet with one rule for 
the root node </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;table&gt;
            Atom data will go here
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Because this style sheet only provides a rule for the root node, and 
because that rule's template does not specify any further processing of child 
nodes, only literal output that's included in the template is inserted in the 
resulting document. In other words, the result of applying the style sheet in 
Listing 17-6 to Listing 17-1 (or any other well-formed XML document) is this: 
</P><PRE><CODE>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
            Atom data will go here
          &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</CODE></PRE>
<H3>Matching element names</H3>
<P class=GX>As previously mentioned, the most basic pattern contains a single 
element name that matches all elements with that name. For example, this 
template matches <CODE>ATOM</CODE> elements and makes their 
<CODE>ATOMIC_NUMBER</CODE> children bold: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;b&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Listing 17-7 demonstrates a style sheet that expands on Listing 
17-6. First, an <CODE>xsl:apply-templates</CODE> element is included in the 
template rule for the root node. This rule uses a <CODE>select</CODE> attribute 
to ensure that only <CODE>PERIODIC_TABLE</CODE> elements are processed. </P>
<P class=GX>Second, a rule that only applies to <CODE>PERIODIC_TABLE</CODE> 
elements is created using <CODE>match="PERIODIC_TABLE"</CODE>. This rule sets up 
the header for the table, and then applies templates to form the body of the 
table from <CODE>ATOM</CODE> elements. </P>
<P class=GX>Finally, the <CODE>ATOM</CODE> rule specifically selects the 
<CODE>ATOM</CODE> element's <CODE>NAME</CODE>, <CODE>ATOMIC_NUMBER</CODE>, and 
<CODE>ATOMIC_WEIGHT</CODE> child elements with <CODE>&lt;xsl:value-of 
select="NAME"/&gt;</CODE>, <CODE>&lt;xsl:value-of 
select="ATOMIC_NUMBER"/&gt;</CODE>, and <CODE>&lt;xsl:value-of 
select="ATOMIC_WEIGHT"/&gt;</CODE>. These are wrapped up inside HTML's 
<CODE>tr</CODE> and <CODE>td</CODE> elements, so that the end result is a table 
of atomic numbers matched to atomic weights. Figure 17-4 shows the output of 
applying the style sheet in Listing 17-7 to the complete periodic table document 
displayed in Netscape Navigator. </P>
<P class=GX>One thing you may wish to note about this style sheet: The exact 
order of the <CODE>NAME</CODE>, <CODE>ATOMIC_NUMBER,</CODE> and 
<CODE>ATOMIC_WEIGHT</CODE> elements in the input document is irrelevant. They 
appear in the output in the order they were selected; that is, first number, 
then weight. Conversely, the individual atoms are sorted in alphabetical order 
as they appear in the input document. Later, you'll see how to use an 
<CODE>xsl:sort</CODE> element to change that so you can arrange the atoms in the 
more conventional atomic number order. </P>
<P style="FONT-WEIGHT: bold">Listing 17-7: Templates applied to specific classes 
of element with select </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:apply-templates select="PERIODIC_TABLE"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;h1&gt;Atomic Number vs. Atomic Weight&lt;/h1&gt;
      &lt;table&gt;
        &lt;th&gt;Element&lt;/th&gt;
        &lt;th&gt;Atomic Number&lt;/th&gt;
        &lt;th&gt;Atomic Weight&lt;/th&gt;
          &lt;xsl:apply-templates select="ATOM"/&gt;
      &lt;/table&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_WEIGHT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<DIV align=center><IMG height=333 alt="Image: 17/picture7.jpg" 
src="XSL Transformations_files/picture7.jpg" width=335></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-4: A table showing atomic number versus 
atomic weight in Netscape Navigator </P>
<H3>Wild cards</H3>
<P class=GX>Sometimes you want a single template to apply to more than one 
element. You can indicate that a template matches all elements by using the 
asterisk wildcard (<CODE>*</CODE>) in place of an element name in the 
<CODE>match</CODE> attribute. For example this template says that all elements 
should be wrapped in a <CODE>P</CODE> element: </P><PRE><CODE>    &lt;xsl:template match="*"&gt;
      &lt;P&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Of course this is probably more than you want. You’d like to use the 
template rules already defined for <CODE>PERIODIC_TABLE</CODE> and 
<CODE>ATOM</CODE> elements as well as the root node and only use this rule for 
the other elements. Fortunately you can. In the event that two rules both match 
a single node, then by default the more specific one takes precedence. In this 
case that means that <CODE>ATOM</CODE> elements will use the template with 
<CODE>match="ATOM"</CODE> instead of a template that merely has 
<CODE>match="*"</CODE>. However, <CODE>NAME</CODE>, <CODE>BOILING_POINT</CODE>, 
<CODE>ATOMIC_NUMBER</CODE> and other elements that don’t match a more specific 
template will cause the <CODE>match="*"</CODE> template to activate. </P>
<P class=GX>You can place a namespace prefix in front of the asterisk to 
indicate that only elements in a particular namespace should be matched. For 
example this template matches all SVG elements, presuming that the prefix 
<CODE>svg</CODE> is mapped to the normal SVG URI 
<CODE>http://www.w3.org/2000/svg</CODE> in the style sheet. </P><PRE><CODE>    &lt;xsl:template match="svg:*"&gt;
      &lt;DIV&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/DIV&gt;
    &lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Of course in Listing 17-1, there aren't any elements from this 
namespace, so this template wouldn’t produce any output. However, it might when 
applied to a different document that did include some SVG. </P>
<H3>Matching children with /</H3>
<P class=GX>You're not limited to the children of the current node in 
<CODE>match</CODE> attributes. You can use the <CODE>/</CODE> symbol to match 
specified hierarchies of elements. Used alone, the <CODE>/</CODE> symbol refers 
to the root node. However, you can use it between two names to indicate that the 
second is the child of the first. For example, <CODE>ATOM/NAME</CODE> refers to 
<CODE>NAME</CODE> elements that are children of <CODE>ATOM</CODE> elements. </P>
<P class=GX>In <CODE>xsl:template</CODE> elements, this enables you to match 
only some of the elements of a given kind. For example, this template rule marks 
<CODE>SYMBOL</CODE> elements that are children of <CODE>ATOM</CODE> elements 
strong. It does nothing to <CODE>SYMBOL</CODE> elements that are not direct 
children of <CODE>ATOM</CODE> elements. </P><PRE><CODE>&lt;xsl:template match="ATOM/SYMBOL"&gt;
  &lt;strong&gt;&lt;xsl:value-of select="."/&gt;&lt;/strong&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Caution</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Remember 
that this rule selects <CODE>SYMBOL</CODE> elements that are children of 
<CODE>ATOM</CODE> elements, not <CODE>ATOM</CODE> elements that have 
<CODE>SYMBOL</CODE> children. In other words, the <CODE>.</CODE> in 
<CODE>&lt;xsl:value-of select="."/&gt;</CODE> refers to the <CODE>SYMBOL</CODE> 
and not to the <CODE>ATOM</CODE>. </P>
<P class=GX>You can specify deeper matches by stringing patterns together. For 
example, <CODE>PERIODIC_TABLE/ATOM/NAME</CODE> selects <CODE>NAME</CODE> 
elements whose parent is an <CODE>ATOM </CODE>element whose parent is a 
<CODE>PERIODIC_TABLE</CODE> element. </P>
<P class=GX>You can also use the <CODE>*</CODE> wild card to substitute for an 
arbitrary element name in a hierarchy. For example, this template rule applies 
to all <CODE>SYMBOL</CODE> elements that are grandchildren of a 
<CODE>PERIODIC_TABLE</CODE> element. </P><PRE><CODE>&lt;xsl:template match="PERIODIC_TABLE/*/SYMBOL"&gt;
  &lt;strong&gt;&lt;xsl:value-of select="."/&gt;&lt;/strong&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Finally, as you saw above, a <CODE>/</CODE> by itself selects the 
root node of the document. For example, this rule applies to all 
<CODE>PERIODIC_TABLE</CODE> elements that are root elements of the document: 
</P><PRE><CODE>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;html&gt;&lt;xsl:apply-templates/&gt;&lt;/html&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>While <CODE>/</CODE> refers to the root node, <CODE>/*</CODE> refers 
to the root element, whatever it is. For example, this template doesn't care 
whether the root element is <CODE>PERIODIC_TABLE</CODE>, <CODE>DOCUMENT</CODE>, 
or <CODE>SCHENECTADY</CODE>. It produces the same output in all cases. </P><PRE><CODE>&lt;xsl:template match="/*"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>Matching descendants with //</H3>
<P class=GX>Sometimes, especially with an uneven hierarchy, you may find it 
easier to bypass intermediate nodes and simply select all the elements of a 
given type, whether they're immediate children, grandchildren, 
great-grandchildren, or what have you. The double slash, <CODE>//</CODE>, refers 
to a descendant element at an arbitrary level. For example, this template rule 
applies to all <CODE>NAME</CODE> descendants of <CODE>PERIODIC_TABLE</CODE>, no 
matter how deep: </P><PRE><CODE>&lt;xsl:template match="PERIODIC_TABLE//NAME"&gt;
  &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The periodic table example is fairly shallow, but this trick becomes 
more important in deeper hierarchies, especially when an element can contain 
other elements of its type (for example, an <CODE>ATOM</CODE> contains an 
<CODE>ATOM</CODE>). </P>
<P class=GX>The <CODE>//</CODE> operator at the beginning of a pattern selects 
any descendant of the root node. For example, this template rule processes all 
<CODE>ATOMIC_NUMBER</CODE> elements while completely ignoring their location: 
</P><PRE><CODE>&lt;xsl:template match="//ATOMIC_NUMBER"&gt;
  &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>Matching by ID</H3>
<P class=GX>You may want to apply a particular style to a particular single 
element without changing all other elements of that type. The simplest way to do 
that in XSLT is to attach a style to the element's ID type attribute. This is 
done with the <CODE>id()</CODE> selector, which contains the ID value in single 
quotes. For example, this rule makes the element with the ID <CODE>e47</CODE> 
bold: </P><PRE><CODE>&lt;xsl:template match="id('e47')"&gt;
  &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This assumes, of course, that the elements that you want to select 
in this fashion have an attribute declared as type <CODE>ID</CODE> in the source 
document's DTD. This may not be the case, however. For one thing, many documents 
do not have DTDs. They're merely well-formed, not valid. And even if they have a 
DTD, there's no guarantee that any element has an <CODE>ID</CODE> type 
attribute. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Cross-Reference</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">ID-type 
attributes are not simply attributes with the name <CODE>ID</CODE>. ID type 
attributes are discussed in Chapter 11. </P>
<H3>Matching attributes with @</H3>
<P class=GX>As you saw in Chapter 5, the <CODE>@</CODE> sign matches against 
attributes and selects nodes according to attribute names. Simply prefix the 
name of the attribute that you want to select with the <CODE>@</CODE> sign. For 
example, this template rule matches <CODE>UNITS</CODE> attributes, and wraps 
them in an <CODE>I</CODE> element. </P><PRE><CODE>    &lt;xsl:template match="@UNITS"&gt;
      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;
    &lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>However, merely adding this rule to the style sheet will not 
automatically produce italicized units in the output because attributes are not 
children of the elements that contain them. Therefore by default when an XSLT 
processor is walking the tree it does not see attribute nodes. You have to 
explicitly process them using <CODE>xsl:apply-templates</CODE> with an 
appropriate <CODE>select</CODE> attribute. Listing 17-8 demonstrates with a 
style sheet that outputs a table of atomic numbers versus melting points. Not 
only is the value of the <CODE>MELTING_POINT</CODE> element written out, so is 
the value of its <CODE>UNITS</CODE> attribute. This is selected by 
<CODE>&lt;xsl:apply-templates select="@UNITS"/&gt;</CODE> in the template rule 
for <CODE>MELTING_POINT</CODE> elements. </P>
<P style="FONT-WEIGHT: bold">Listing 17-8: An XSLT style sheet that selects the 
UNITS attribute with @ </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Melting Point&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Melting Point&lt;/th&gt;
            &lt;xsl:apply-templates/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:apply-templates select="@UNITS"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="@UNITS"&gt;
      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Recall that the value of an attribute node is simply the normalized 
string value of the attribute. Once you apply the style sheet in Listing 17-8, 
<CODE>ATOM</CODE> elements come out formatted like this: </P><PRE><CODE>  &lt;tr&gt;
&lt;td&gt;Hydrogen&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;13.81&lt;I&gt;Kelvin&lt;/I&gt;&lt;/td&gt;
&lt;/tr&gt;
  &lt;tr&gt;
&lt;td&gt;Helium&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0.95&lt;I&gt;Kelvin&lt;/I&gt;&lt;/td&gt;
&lt;/tr&gt;
</CODE></PRE>
<P class=GX>You can combine attributes with elements using the various hierarchy 
operators. For example, the pattern <CODE>BOILING_POINT/@UNITS</CODE> refers to 
the <CODE>UNITS</CODE> attribute of a <CODE>BOILING_POINT</CODE> element. 
<CODE>ATOM/*/@UNITS</CODE> matches any <CODE>UNITS</CODE> attribute of a child 
element of an <CODE>ATOM</CODE> element. This is especially helpful when 
matching against attributes in template rules. You must remember that what's 
being matched is the attribute node, not the element that contains it. It's a 
very common mistake to implicitly confuse the attribute node with the element 
node that contains it. For example, consider this rule, which attempts to apply 
templates to all child elements that have <CODE>UNITS</CODE> attributes: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:apply-templates select="@UNITS"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>What it actually does is apply templates to the nonexistent 
<CODE>UNITS</CODE> attributes of <CODE>ATOM</CODE> elements. </P>
<P class=GX>You can also use the <CODE>@*</CODE> wild card to match all 
attributes of an element, for example <CODE>BOILING_POINT/@*</CODE> to match all 
attributes of <CODE>BOILING_POINT</CODE> elements. You can also add a namespace 
prefix after the <CODE>@</CODE> to match all attributes in a declared namespace. 
For instance, <CODE>@xlink:*</CODE> matches all the XLink attributes, such as 
<CODE>xlink:show</CODE>, <CODE>xlink:type</CODE>, and <CODE>xlink:href</CODE>, 
assuming the <CODE>xlink</CODE> prefix is mapped to the 
<CODE>http://www.w3.org/1999/xlink</CODE> XLink namespace URI. </P>
<H3>Matching comments with comment()</H3>
<P class=GX>Most of the time you should simply ignore comments in XML documents. 
Making comments an essential part of a document is a very bad idea. Nonetheless, 
XSLT does provide a means to match a comment if you absolutely have to. </P>
<P class=GX>To match a comment, use the <CODE>comment()</CODE> pattern. Although 
this pattern has function-like parentheses, it never actually takes any 
arguments. For example, this template rule italicizes all comments: </P><PRE><CODE>    &lt;xsl:template match="comment()"&gt;
      &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
    &lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>To distinguish between different comments, you have to look at the 
comments' parent and ancestors. For example, recall that a <CODE>DENSITY</CODE> 
element looks like this: </P><PRE><CODE>    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
</CODE></PRE>
<P class=GX>You can use the hierarchy operators to select particular comments. 
For example, this rule only matches comments that occur inside 
<CODE>DENSITY</CODE> elements: </P><PRE><CODE>&lt;xsl:template match="DENSITY/comment()"&gt;
  &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The only reason Listing 17-1 uses a comment to specify conditions 
instead of an attribute or element is precisely for this example. In practice, 
you should never put important information in comments. The real reason XSLT 
allows you to select comments is so that a style sheet can transform from one 
XML application to another while leaving the comments intact. Any other use 
indicates a poorly designed original document. The following rule matches all 
comments, and copies them back out again using the <CODE>xsl:comment</CODE> 
element. </P><PRE><CODE>&lt;xsl:template match="comment()"&gt;
  &lt;xsl:comment&gt;&lt;xsl:value-of select="."/&gt;&lt;/xsl:comment&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>Matching processing instructions with processing-instruction()</H3>
<P class=GX>When it comes to writing structured, intelligible, maintainable XML, 
processing instructions aren't much better than comments. However, there are 
occasional genuine needs for them, including attaching style sheets to 
documents. </P>
<P class=GX>The <CODE>processing-instruction()</CODE> function matches 
processing instructions. The argument to <CODE>processing-instruction()</CODE> 
is a quoted string giving the target of the processing instruction to select. If 
you do not include an argument, the first processing instruction child of the 
current node is matched. For example, this rule matches the processing 
instruction children of the root node (most likely the 
<CODE>xml-stylesheet</CODE> processing instruction). The 
<CODE>xsl:processing-instruction</CODE> element inserts a processing instruction 
with the specified name and value in the output document. </P><PRE><CODE>&lt;xsl:template match="/processing-instruction()"&gt;
  &lt;xsl:processing-instruction name="xml-stylesheet"&gt;
    type="text/xml" value="auto.xsl"
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This rule also matches the <CODE>xml-stylesheet</CODE> processing 
instruction, but by its name: </P><PRE><CODE>&lt;xsl:template
  match="processing-instruction('xml-stylesheet')"&gt;
  &lt;xsl:processing-instruction name="xml-stylesheet"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>In fact, one of the primary reasons for distinguishing between the 
root element and the root node is so that processing instructions from the 
prolog can be read and processed. Although the <CODE>xml-stylesheet</CODE> 
processing instruction uses a name = value syntax, XSL does not consider these 
to be attributes because processing instructions are not elements. The value of 
a processing instruction is simply everything between the white space following 
its name and the closing <CODE>?&gt;</CODE>. </P>
<H3>Matching text nodes with text()</H3>
<P class=GX>Text nodes are generally ignored as nodes, although their values are 
included as part of the value of a selected element. However, the 
<CODE>text()</CODE> operator does enable you to specifically select the text 
child of an element. Despite the parentheses, this operator takes no arguments. 
For example, this rule emboldens all text: </P><PRE><CODE>&lt;xsl:template match="text()"&gt;
  &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The main reason this operator exists is for the default rules. XSLT 
processors must provide the following default rule whether the author specifies 
it or not: </P><PRE><CODE>&lt;xsl:template match="text()"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This means that whenever a template is applied to a text node, the 
text of the node is output. If you do not want the default behavior, you can 
override it. For example, including the following empty template rule in your 
style sheet will prevent text nodes from being output unless specifically 
matched by another rule. </P><PRE><CODE>&lt;xsl:template match="text()"&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>Using the or operator |</H3>
<P class=GX>The vertical bar (<CODE>|</CODE>)allows a template rule to match 
multiple patterns. If a node matches one pattern or the other, it will activate 
the template. For example, this template rule matches both 
<CODE>ATOMIC_NUMBER</CODE> and <CODE>ATOMIC_WEIGHT</CODE> elements: </P><PRE><CODE>&lt;xsl:template match="ATOMIC_NUMBER|ATOMIC_WEIGHT"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>You can include white space around the <CODE>|</CODE> if that makes 
the code clearer. For example, </P><PRE><CODE>&lt;xsl:template match="ATOMIC_NUMBER | ATOMIC_WEIGHT"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>You can also use more than two patterns in sequence. For example, 
this template rule applies to <CODE>ATOMIC_NUMBER</CODE>, 
<CODE>ATOMIC_WEIGHT</CODE>, and <CODE>SYMBOL</CODE> elements (that is, it 
matches <CODE>ATOMIC_NUMBER</CODE>, <CODE>ATOMIC_WEIGHT</CODE> and 
<CODE>SYMBOL</CODE> elements): </P><PRE><CODE>&lt;xsl:template match="ATOMIC_NUMBER | ATOMIC_WEIGHT | SYMBOL"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>/</CODE> operator is evaluated before the <CODE>|</CODE> 
operator. Thus, the following template rule matches an 
<CODE>ATOMIC_NUMBER</CODE> child of an <CODE>ATOM</CODE>, or an 
<CODE>ATOMIC_WEIGHT</CODE> of unspecified parentage, not an 
<CODE>ATOMIC_NUMBER</CODE> child of an <CODE>ATOM</CODE> or an 
<CODE>ATOMIC_WEIGHT</CODE> child of an <CODE>ATOM</CODE>. </P><PRE><CODE>&lt;xsl:template match="ATOM/ATOMIC_NUMBER|ATOMIC_WEIGHT"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>Testing with [ ]</H3>
<P class=GX>So far, I've merely tested for the presence of various nodes. 
However, you can test for more details about the nodes that match a pattern 
using <CODE>[]</CODE>. You can perform many different tests including: </P>
<UL>
  <LI>Whether an element contains a given child, attribute, or other node 
  <LI>Whether the value of an attribute is a certain string 
  <LI>Whether the value of an element matches a string 
  <LI>What position a given node occupies in the hierarchy </LI></UL>
<P class=GX>For example, seaborgium, element 106, has only been created in 
microscopic quantities. Even its most long-lived isotope has a half-life of only 
30 seconds. With such a hard-to-create, short-lived element, it's virtually 
impossible to measure the density, melting point, and other bulk properties. 
Consequently, the periodic table document omits the elements describing the bulk 
properties of seaborgium and similar atoms because the data simply doesn’t 
exist. If you want to create a table of atomic number versus melting point, you 
should omit those elements with unknown melting points. To do this, you can 
provide one template for <CODE>ATOM</CODE> elements that have 
<CODE>MELTING_POINT</CODE> children and another one for elements that don't, 
like this: </P><PRE><CODE>&lt;!-- Include nothing for arbitrary atoms --&gt;
&lt;xsl:template match="ATOM" /&gt;
&lt;!-- Include a table row for atoms that do have 
     melting points. This rule will override the 
     previous one for those atoms that do have 
     melting points. --&gt;
&lt;xsl:template match="ATOM[MELTING_POINT]"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:value-of select="MELTING_POINT"/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Note here, that it is the <CODE>ATOM</CODE> element being matched, 
not the <CODE>MELTING_POINT</CODE> element as in the case of 
<CODE>ATOM/MELTING_POINT</CODE>. </P>
<P class=GX>The test brackets can contain more than simply a child-element name. 
In fact, they can contain any XPath expression. (XPath expressions are a 
superset of match patterns that are discussed in the next section.) If the 
specified element has a child matching that expression, it is considered to 
match the total pattern. For example, this template rule matches 
<CODE>ATOM</CODE> elements with <CODE>NAME</CODE> or <CODE>SYMBOL</CODE> 
children. </P><PRE><CODE>&lt;xsl:template match="ATOM[NAME | SYMBOL]"&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This template rule matches <CODE>ATOM</CODE> elements with a 
<CODE>DENSITY</CODE> child element that has a <CODE>UNITS</CODE> attribute: </P><PRE><CODE>&lt;xsl:template match="ATOM[DENSITY/@UNITS]"&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>To revisit an earlier example, to correctly find all child elements 
that have <CODE>UNITS</CODE> attributes, use <CODE>*</CODE> to find all elements 
and <CODE>[@UNITS]</CODE> to winnow those down to the ones with 
<CODE>UNITS</CODE> attributes, like this: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:apply-templates select="*[@UNITS]"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>One type of pattern testing that proves especially useful is string 
equality. An equals sign (<CODE>=</CODE>) can test whether the value of a node 
identically matches a given string. For example, this template finds the 
<CODE>ATOM</CODE> element that contains an <CODE>ATOMIC_NUMBER</CODE> element 
whose content is the string <CODE>10</CODE> (Neon). </P><PRE><CODE>&lt;xsl:template match="ATOM[ATOMIC_NUMBER='10']"&gt;
  This is Neon!
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Testing against element content may seem extremely tricky because of 
the need to get the value exactly right, including white space. You may find it 
easier to test against attribute values since those are less likely to contain 
insignificant white space. For example, the style sheet in Listing 17-9 applies 
templates only to those <CODE>ATOM</CODE> elements whose <CODE>STATE</CODE> 
attribute value is the three letters <CODE>GAS</CODE>. </P>
<P style="FONT-WEIGHT: bold">Listing 17-9: An XSLT style sheet that selects only 
those ATOM elements whose STATE attribute has the value GAS </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;Gases&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"/&gt;
  &lt;xsl:template match="ATOM[@STATE='GAS']"&gt;
    &lt;P&gt;&lt;xsl:value-of select="."/&gt;&lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>You can use other XPath expressions for more complex matches. For 
example, you can select all elements whose names begin with "A" or all elements 
with an atomic number less than 100. </P>
<H2><A name=d1e3567>XPath Expressions for Selecting Nodes</A></H2>
<P class=GX>The <CODE>select</CODE> attribute is used in 
<CODE>xsl:apply-templates</CODE>, <CODE>xsl:value-of</CODE>, 
<CODE>xsl:for-each</CODE>, <CODE>xsl:copy-of</CODE>, <CODE>xsl:variable</CODE>, 
<CODE>xsl:param</CODE>, and <CODE>xsl:sort</CODE> to specify exactly which nodes 
are operated on. The value of this attribute is an <SPAN 
class=italic>expression</SPAN> written in the XPath language. The XPath language 
provides a means of identifying a particular element, group of elements, text 
fragment, or other part of an XML document. The XPath syntax is used both for 
XSLT and XPointer. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Cross-reference</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">XPointers 
are discussed in Chapter 20. XPath is discussed further in that chapter as 
well.</P>
<P class=GX>Expressions are a superset of the match patterns discussed in the 
last section. That is, all match patterns are expressions, but not all 
expressions are match patterns. Recall that match patterns enable you to match 
nodes by element name, child elements, descendants, and attributes, as well as 
by making simple tests on these items. XPath expressions allow you to select 
nodes through all these criteria but also by referring to ancestor nodes, parent 
nodes, sibling nodes, preceding nodes, and following nodes. Furthermore, 
expressions aren't limited to producing merely a list of nodes, but can also 
produce booleans, numbers, and strings. </P>
<H3>Node axes</H3>
<P class=GX>Expressions are not limited to specifying the children and 
descendants of the current node. XPath provides a number of axes that you can 
use to select from different parts of the tree relative to some particular node 
in the tree called the context node. In XSLT, the context node is normally 
initialized to the current node that the template matches, though there are ways 
to change this. Table 17-2 summarizes the axes and their meanings. </P>
<P 
style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans; TEXT-ALIGN: center">Table 
17-2: Expression Axes </P>
<TABLE summary="(unspecified contents)" border=1>
  <COLGROUP>
  <COL width=103>
  <COL width=333></COLGROUP>
  <TBODY>
  <TR>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Axis: 
      </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Selects 
      From: </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>ancestor</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The parent of the context node, the parent of the parent of 
      the context node, the parent of the parent of the parent of the context 
      node, and so forth back to the root node </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>ancestor-or-self</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The ancestors of the context node and the context node 
      itself</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>attribute</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The attributes of the context node</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>child</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The immediate children of the context node</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>descendant</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The children of the context node, the children of the children 
      of the context node, and so forth</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>descendant-or-self</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The context node itself and its descendants</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>following</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>All nodes that start after the end of the context node, 
      excluding attribute and namespace nodes</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>following-sibling</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>All nodes that start after the end of the context node and 
      have the same parent as the context node</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>namespace</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The namespace of the context node</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>parent</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The unique parent node of the context node</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>preceding</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>All nodes that finish before the beginning of the context 
      node, excluding attribute and namespace nodes </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>preceding-sibling</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>All nodes that start before the beginning of the context node 
      and have the same parent as the context node</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>self</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>The context node</P></TD></TR></TBODY></TABLE>
<P class=GX>Choosing an axis limits the expression so that it only selects from 
the set of nodes indicated in the second column of Table 17-2. The axis is 
generally followed by a double colon (<CODE>::</CODE>) and a node test that 
further winnows down this node set. For example, a node test may contain the 
name of the element to be selected as in the following template rule: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="child::NAME"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="child::ATOMIC_NUMBER"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="child::ATOMIC_WEIGHT"/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The template rule matches <CODE>ATOM</CODE> elements. When an 
<CODE>ATOM</CODE> element is matched, that element becomes the context node. A 
<CODE>NAME</CODE> element, an <CODE>ATOMIC_NUMBER</CODE> element, and an 
<CODE>ATOMIC_WEIGHT</CODE> element are all selected from the children of that 
matched <CODE>ATOM</CODE> element and output as table cells. (If there's one 
more than one of these desired elements — for example, three <CODE>NAME</CODE> 
elements — then all are selected but only the value of the first one is taken.) 
</P>
<P class=GX>The <CODE>child</CODE> axis doesn't let you do anything that you 
can't do with element names alone. In fact <CODE>select="ATOMIC_WEIGHT"</CODE> 
is just an abbreviated form of <CODE>select="child::ATOMIC_WEIGHT"</CODE>. 
However, the other axes are a little more interesting. </P>
<P class=GX>Referring to the parent element is illegal in match patterns, but 
not in expressions. To refer to the parent, you use the <CODE>parent</CODE> 
axis. For example, this template matches <CODE>BOILING_POINT</CODE> elements but 
outputs the value of the parent <CODE>ATOM</CODE> element: </P><PRE><CODE>&lt;xsl:template match="BOILING_POINT"&gt;
  &lt;P&gt;&lt;xsl:value-of select="parent::ATOM"/&gt;&lt;/P&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Some radioactive atoms such as polonium have half-lives so short 
that bulk properties such as the boiling point and melting point can't be 
measured. Therefore, not all <CODE>ATOM</CODE> elements necessarily have 
<CODE>BOILING_POINT</CODE> child elements. The above rule enables you to write a 
template that only outputs those elements that actually have boiling points. 
Expanding on this example, Listing 17-10 matches the <CODE>MELTING_POINT</CODE> 
elements but actually outputs the parent <CODE>ATOM</CODE> element using 
<CODE>parent::ATOM</CODE>. </P>
<P style="FONT-WEIGHT: bold">Listing 17-10: A style sheet that outputs only 
those elements with known melting points </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;xsl:apply-templates select="PERIODIC_TABLE"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;h1&gt;Elements with known Melting Points&lt;/h1&gt;
      &lt;xsl:apply-templates select=".//MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
      &lt;p&gt;
        &lt;xsl:value-of select="parent::ATOM"/&gt;
      &lt;/p&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Once in awhile, you may need to select the nearest ancestor of an 
element with a given type. The <CODE>ancestor</CODE> axis does this. For 
example, this rule inserts the value of the nearest <CODE>PERIODIC_TABLE</CODE> 
element that contains the matched <CODE>SYMBOL</CODE> element. </P><PRE><CODE>&lt;xsl:template match="SYMBOL"&gt;
  &lt;xsl:value-of select="ancestor::PERIODIC_TABLE"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>ancestor-or-self</CODE> axis behaves like the 
<CODE>ancestor</CODE> axis except that if the context node passes the node test, 
then it will be returned as well. For example, this rule matches all elements. 
If the matched element is a <CODE>PERIODIC_TABLE</CODE>, then that very 
<CODE>PERIODIC_TABLE</CODE> is selected in <CODE>xsl:value-of</CODE>. </P><PRE><CODE>&lt;xsl:template match="*"&gt;
  &lt;xsl:value-of select="ancestor-or-self::PERIODIC_TABLE"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H4>Node tests</H4>
<P class=GX>Instead of the name of a node, the axis may be followed by one of 
these four node-type functions:</P>
<UL>
  <LI><CODE>comment()</CODE> 
  <LI><CODE>text()</CODE> 
  <LI><CODE>processing-instruction()</CODE> 
  <LI><CODE>node()</CODE> </LI></UL>
<P class=GX>The <CODE>comment()</CODE> function selects a comment node. The 
<CODE>text()</CODE> function selects a text node. The 
<CODE>processing-instruction()</CODE> function selects a processing instruction 
node, and the <CODE>node()</CODE> function selects any type of node. (The 
<CODE>*</CODE> wild card only selects element nodes.) The 
<CODE>processing-instruction()</CODE> node type can also contain an optional 
argument specifying the name of the processing instruction to select. </P>
<H4>Hierarchy operators</H4>
<P class=GX>You can use the <CODE>/</CODE> and <CODE>//</CODE> operators to 
string expressions together. For example, Listing 17-11 prints a table of 
element names, atomic numbers, and melting points for only those elements that 
have melting points. It does this by selecting the parent of the 
<CODE>MELTING_POINT</CODE> element, then finding that parent's <CODE>NAME</CODE> 
and <CODE>ATOMIC_NUMBER</CODE> children with 
<CODE>select="parent::*/child::NAME)"</CODE>. </P>
<P style="FONT-WEIGHT: bold">Listing 17-11: A table of melting point versus 
atomic number </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Melting Point&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Melting Point&lt;/th&gt;
            &lt;xsl:apply-templates select="child::ATOM"/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;xsl:apply-templates
       select="child::MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
       &lt;tr&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="parent::*/child::NAME"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of
         select="parent::*/child::ATOMIC_NUMBER"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="self::*"/&gt;
          &lt;xsl:value-of select="attribute::UNITS"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>This is not the only way to solve the problem. Another possibility 
is to use the <CODE>preceding-sibling</CODE> and <CODE>following-sibling</CODE> 
axes, or both if the relative location (preceding or following) is uncertain. 
The necessary template rule for the <CODE>MELTING_POINT</CODE> element looks 
like this: </P><PRE><CODE> &lt;xsl:template match="MELTING_POINT"&gt;
    &lt;tr&gt;
     &lt;td&gt;
       &lt;xsl:value-of
        select="preceding-sibling::NAME
              | following-sibling::NAME"/&gt;
     &lt;/td&gt;
     &lt;td&gt;
       &lt;xsl:value-of
        select="preceding-sibling::ATOMIC_NUMBER
              | following-sibling::ATOMIC_NUMBER"/&gt;
     &lt;/td&gt;
     &lt;td&gt;
       &lt;xsl:value-of select="self::*"/&gt;
       &lt;xsl:value-of select="attribute::UNITS"/&gt;
     &lt;/td&gt;
   &lt;/tr&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H4>Abbreviated syntax</H4>
<P class=GX>The various axes in Table 17-2 are a bit too wordy for comfortable 
typing. XPath also defines an abbreviated syntax that can substitute for the 
most common of these axes and is more used in practice. Table 17-3 shows the 
full and abbreviated equivalents. </P>
<P 
style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans; TEXT-ALIGN: center">Table 
17-3: Abbreviated Syntax for XPath Expressions </P>
<TABLE summary="(unspecified contents)" border=1>
  <COLGROUP>
  <COL width=117>
  <COL width=320></COLGROUP>
  <TBODY>
  <TR>
    <TD vAlign=top>
      <P 
      style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Abbreviation: 
      </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Full: 
      </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>.</P></TD>
    <TD vAlign=top>
      <P class=TX>self::node()</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>..</P></TD>
    <TD vAlign=top>
      <P class=TX>parent::node()</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><SPAN class=italic>name</SPAN></P></TD>
    <TD vAlign=top>
      <P class=TX>child::<SPAN class=italic>name</SPAN></P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>@<SPAN class=italic>name</SPAN></P></TD>
    <TD vAlign=top>
      <P class=TX>attribute::<SPAN class=italic>name</SPAN></P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX>//</P></TD>
    <TD vAlign=top>
      <P class=TX>/descendant-or-self::node()/</P></TD></TR></TBODY></TABLE>
<P class=GX>Listing 17-12 demonstrates by rewriting Listing 17-11 using the 
abbreviated syntax. The output produced by the two style sheets is exactly the 
same, however. </P>
<P style="FONT-WEIGHT: bold">Listing 17-12: A table of melting point versus 
atomic number using the abbreviated syntax </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Melting Point&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Melting Point&lt;/th&gt;
            &lt;xsl:apply-templates select="ATOM"/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;xsl:apply-templates
       select="MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
       &lt;tr&gt;
        &lt;td&gt;
          &lt;xsl:value-of
           select="../NAME"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of
         select="../ATOMIC_NUMBER"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="."/&gt;
          &lt;xsl:value-of select="@UNITS"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Match patterns can only use the abbreviated syntax and the 
<CODE>child</CODE> and <CODE>attribute</CODE> axes. The full syntax using the 
axes of Table 17-2 is restricted to expressions. </P>
<H3>Expression types</H3>
<P class=GX>Every expression evaluates to a single value. For example, the 
expression <CODE>3 + 2</CODE> evaluates to the value <CODE>5</CODE>. The 
expressions used so far have all evaluated to node sets. However, there are five 
types of expressions in XSLT: </P>
<UL>
  <LI>Node sets 
  <LI>Booleans 
  <LI>Numbers 
  <LI>Strings 
  <LI>Result tree fragments </LI></UL>
<H4>Node sets</H4>
<P class=GX>A node set is an unordered group of nodes from the input document. 
The axes in Table 17-2 all return a node set containing the nodes they match. 
Which nodes are in the node set depends on the context node, the node test, and 
the axis. </P>
<P class=GX>For example, when the context node is the 
<CODE>PERIODIC_TABLE</CODE> element of Listing 17-1, the XPath expression 
<CODE>select="child::ATOM"</CODE> returns a node set that contains both 
<CODE>ATOM</CODE> elements in that document. The XPath expression 
<CODE>select="child::ATOM/child::NAME"</CODE> returns a node set containing the 
two element nodes <CODE>&lt;NAME&gt;Hydrogen&lt;/NAME&gt;</CODE> and 
<CODE>&lt;NAME&gt;Helium&lt;/NAME&gt;</CODE> when the context node is the 
<CODE>PERIODIC_TABLE</CODE> element of Listing 17-1. </P>
<P class=GX>The context node is a member of the <SPAN class=italic>context node 
list</SPAN>. The context node list is that group of elements that all match the 
same rule at the same time, generally as a result of one 
<CODE>xsl:apply-templates</CODE> or <CODE>xsl:for-each</CODE> call. For 
instance, when Listing 17-12 is applied to Listing 17-1, the <CODE>ATOM</CODE> 
template is invoked twice, first for the hydrogen atom, then for the helium 
atom. The first time it's invoked, the context node is the hydrogen 
<CODE>ATOM</CODE> element. The second time it's invoked, the context node is the 
helium <CODE>ATOM</CODE> element. However, both times the context node list is 
the set containing both the helium and hydrogen <CODE>ATOM</CODE> elements. </P>
<P class=GX>Table 17-4 lists a number of functions that operate on node sets, 
either as arguments or as the context node.</P>
<P 
style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans; TEXT-ALIGN: center">Table 
17-4: Functions That Operate on or Return Node Sets </P>
<TABLE summary="(unspecified contents)" border=1>
  <COLGROUP>
  <COL width=108>
  <COL width=76>
  <COL width=252></COLGROUP>
  <TBODY>
  <TR>
    <TD vAlign=top>
      <P 
      style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Function: 
      </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Return 
      Type: </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Returns: 
      </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>position()</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>number</P></TD>
    <TD vAlign=top>
      <P class=TX>The position of the context node in the context node list; the 
      first node in the list has position 1</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>last()</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>number</P></TD>
    <TD vAlign=top>
      <P class=TX>The number of nodes in the context node list; this is the same 
      as the position of the last node in the list</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>count(</CODE><SPAN 
      class=italic><CODE>node-set</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>number</P></TD>
    <TD vAlign=top>
      <P class=TX>The number of nodes in <SPAN 
      class=italic><CODE>node-set</CODE></SPAN>. </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>id(</CODE><SPAN class=italic><CODE>string1 string2 
      string3…</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>node set</P></TD>
    <TD vAlign=top>
      <P class=TX>A node set containing all the elements anywhere in the same 
      document that have an ID named in the argument list; the empty set if no 
      element has the specified ID. </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>key(</CODE><SPAN class=italic><CODE>string 
      name</CODE></SPAN><CODE>, </CODE><SPAN class=italic><CODE>Object 
      value</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>node set</P></TD>
    <TD vAlign=top>
      <P class=TX>A node set containing all nodes in this document that have a 
      key with the specified value. Keys are set with the top-level 
      <CODE>xsl:key</CODE> element. </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>document(</CODE><SPAN class=italic><CODE>string URI, 
      string base</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>node set</P></TD>
    <TD vAlign=top>
      <P class=TX>A node set in the document referred to by the URI; the nodes 
      are chosen from the named anchor or XPointer used by the URI. If there is 
      no named anchor or XPointer, then the root element of the named document 
      is the node set. Relative URIs are relative to the base URI given in the 
      second argument. If the second argument is omitted, then relative URIs are 
      relative to the URI of the style sheet (not the source document!). 
  </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>local-name(</CODE><SPAN class=italic><CODE>node 
      set</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>string</P></TD>
    <TD vAlign=top>
      <P class=TX>The local name (everything after the namespace prefix) of the 
      first node in the <SPAN class=italic><CODE>node set</CODE></SPAN> 
      argument; can be used without any arguments to get the local name of the 
      context node. </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>namespace-uri(</CODE><SPAN class=italic><CODE>node 
      set</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>string</P></TD>
    <TD vAlign=top>
      <P class=TX>The URI of the namespace of the first node in the node set; 
      can be used without any arguments to get the URI of the namespace of the 
      context node; returns an empty string if the node is not in a namespace. 
      </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>name(</CODE><SPAN class=italic><CODE>node 
      set</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>string</P></TD>
    <TD vAlign=top>
      <P class=TX>The qualified name (both prefix and local part) of the first 
      node in the <SPAN class=italic><CODE>node set</CODE></SPAN> argument; can 
      be used without an argument to get the qualified name of the context node. 
      </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>generate-id(</CODE><SPAN class=italic><CODE>node 
      set</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>string</P></TD>
    <TD vAlign=top>
      <P class=TX>A unique identifier for the first node in the argument <SPAN 
      class=italic><CODE>node set</CODE></SPAN>; can be used without any 
      argument to generate an ID for the context node. </P></TD></TR></TBODY></TABLE>
<P class=GX>If an argument of the wrong type is passed to one of these 
functions, then XSLT will attempt to convert that argument to the correct type; 
for instance, by converting the number 12 to the string "12". However, no 
arguments may be converted to node sets. </P>
<P class=GX>The <CODE>position()</CODE> function can be used to determine an 
element's position within a node set. Listing 17-13 is a style sheet that 
prefixes the name of each atom's name with its position in the document using 
<CODE>&lt;xsl:value-of select="position()"/&gt;</CODE>. </P>
<P style="FONT-WEIGHT: bold">Listing 17-13: A style sheet that numbers the atoms 
in the order they appear in the document </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/PERIODIC_TABLE"&gt;
    &lt;HTML&gt;
      &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;
      &lt;BODY&gt;
        &lt;xsl:apply-templates select="ATOM"/&gt;
      &lt;/BODY&gt;
    &lt;/HTML&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;P&gt;
      &lt;xsl:value-of select="position()"/&gt;.
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>When this style sheet is applied to Listing 17-1, the output is 
this:</P><PRE><CODE>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;The Elements&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;P&gt;1.
      Hydrogen&lt;/P&gt;
&lt;P&gt;2.
      Helium&lt;/P&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</CODE></PRE>
<H4>Booleans</H4>
<P class=GX>A boolean has one of two values: true or false. XSLT allows any kind 
of data to be transformed into a boolean. This is often done implicitly when a 
string or a number or a node set is used where a boolean is expected, as in the 
<CODE>test</CODE> attribute of an <CODE>xsl:if</CODE> element. These conversions 
can also be performed by the <CODE>boolean()</CODE> function which converts an 
argument of any type to a boolean according to these rules: </P>
<UL>
  <LI>A number is false if it's zero or NaN (a special symbol meaning Not a 
  Number, used for the result of dividing by zero and similar illegal 
  operations); true otherwise. 
  <LI>An empty node set is false. All other node sets are true. 
  <LI>An empty result tree fragment is false. All other result tree fragments 
  are true. 
  <LI>A zero length string is false. All other strings are true. </LI></UL>
<P class=GX>Booleans are also produced as the result of expressions involving 
these operators:</P>
<UL>
  <LI><CODE>=</CODE>&nbsp;equal to 
  <LI>!<CODE>=</CODE>&nbsp;not equal to 
  <LI><CODE>&lt;</CODE>&nbsp;less than (really <CODE>&amp;lt;</CODE>) 
  <LI><CODE>&gt;</CODE>&nbsp;greater than 
  <LI><CODE>&lt;=</CODE>&nbsp;less than or equal to (really 
  <CODE>&amp;lt;=</CODE>) 
  <LI><CODE>&gt;=</CODE>&nbsp;greater than or equal to </LI></UL>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Caution</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">The 
<CODE>&lt;</CODE> sign is illegal in attribute values. Consequently, it must be 
replaced by <CODE>&amp;lt;</CODE> even when used as the less-than operator. </P>
<P class=GX>These operators are most commonly used in predicate tests to 
determine whether a rule should be invoked. An XPath expression can contain not 
only a pattern that selects certain nodes, but also a predicate that further 
filters the set of nodes selected. For example, <CODE>child::ATOM</CODE> selects 
all the <CODE>ATOM</CODE> children of the context node. However, 
<CODE>child::ATOM[position()=1]</CODE> selects only the first <CODE>ATOM</CODE> 
child of the context node. <CODE>[position()=1]</CODE> is a predicate on the 
node test <CODE>ATOM</CODE> that returns a boolean result: True if the position 
of the <CODE>ATOM</CODE> is equal to one; false otherwise. Each node test can 
have any number of predicates. However, more than one is unusual. </P>
<P class=GX>For example, this template rule applies to the first 
<CODE>ATOM</CODE> element in the periodic table, but not to subsequent ones, by 
testing whether or not the position of the element equals 1. </P><PRE><CODE>&lt;xsl:template match="PERIODIC_TABLE/ATOM[position()=1]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This template rule applies to all <CODE>ATOM</CODE> elements that 
are not the first child element of the <CODE>PERIODIC_TABLE</CODE> by testing 
whether the position is greater than 1: </P><PRE><CODE>&lt;xsl:template match="PERIODIC_TABLE/ATOM[position()&gt;1]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The keywords <CODE>and</CODE> and <CODE>or</CODE> logically combine 
two boolean expressions according to the normal rules of logic. For example, 
suppose you want a template that matches an <CODE>ATOMIC_NUMBER</CODE> element 
that is both the first and last child of its parent element; that is, it is the 
only element of its parent. This template rule uses <CODE>and</CODE> to 
accomplish that: </P><PRE><CODE>&lt;xsl:template
 match="ATOMIC_NUMBER[position()=1 and position()=last()]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>If the first condition is false, then the complete <CODE>and</CODE> 
expression is guaranteed to be false. Consequently, the second condition won't 
be checked. </P>
<P class=GX>This template matches both the first and last <CODE>ATOM</CODE> 
elements in their parent by matching when the position is 1 or when the position 
is equal to the number of elements in the set: </P><PRE><CODE>&lt;xsl:template match="ATOM[position()=1 or position()=last()]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This is logical <CODE>or</CODE>, so it will also match if both 
conditions are true. That is, it will match an <CODE>ATOM</CODE> that is both 
the first and last child of its parent. If the first condition is true, then the 
complete <CODE>or</CODE> expression is guaranteed to be true. Consequently, the 
second condition won't be checked. </P>
<P class=GX>The <CODE>not()</CODE> function reverses the result of an operation. 
For example, this template rule matches all <CODE>ATOM</CODE> elements that are 
not the first child of their parents: </P><PRE><CODE>&lt;xsl:template match="ATOM[not(position()=1)]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The same template rule could be written using the not equal operator 
<CODE>!=</CODE> instead: </P><PRE><CODE>&lt;xsl:template match="ATOM[position()!=1]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This template rule matches all <CODE>ATOM</CODE> elements that are 
neither the first nor last <CODE>ATOM</CODE> child of their parent: </P><PRE><CODE>&lt;xsl:template match =
 "ATOM[not(position()=1 or position()=last())]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>XSLT does not have an exclusive <CODE>or</CODE> operator. However, 
one can be formed by judicious use of <CODE>not()</CODE>, <CODE>and</CODE>, and 
<CODE>or</CODE>. For example, this rule selects those <CODE>ATOM</CODE> elements 
that are either the first or last child, but not both: </P><PRE><CODE>&lt;xsl:template
 match="ATOM[(position()=1 or position()=last())
              and not(position()=1 and position()=last())]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>There are three remaining functions that return booleans:</P>
<UL>
  <LI><SPAN style="FONT-FAMILY: Arial"><SPAN 
  class=bold></SPAN></SPAN><CODE>true()</CODE> always returns true 
  <LI><CODE>false()</CODE> always returns false 
  <LI><CODE>lang(</CODE><SPAN 
  class=italic><CODE>code</CODE></SPAN><CODE>)</CODE> returns true if the 
  current node has the same language (as given by the <CODE>xml:lang</CODE> 
  attribute) as the <SPAN class=italic><CODE>code</CODE></SPAN> argument. 
</LI></UL>
<H4>Numbers</H4>
<P class=GX>XPath numbers are 64-bit IEEE 754 floating-point doubles. Even 
numbers like 42 or -7000 that look like integers are stored as doubles. 
Nonnumber values such as strings and booleans are converted to numbers 
automatically as necessary, or at user request through the <CODE>number()</CODE> 
function using these rules: </P>
<UL>
  <LI>Booleans are 1 if true; 0 if false. 
  <LI>A string is trimmed of leading and trailing white space, then converted to 
  a number in the fashion you would expect; for example, the string "12" is 
  converted to the number 12. If the string cannot be interpreted as a number, 
  then it is converted to the special symbol NaN, which stands for Not a Number. 

  <LI>Node sets and result tree fragments are converted to strings; the string 
  is then converted to a number. </LI></UL>
<P class=GX>For example, this template only outputs the nonnaturally occurring 
transuranium elements; that is, those elements with atomic numbers greater than 
92 (the atomic number of uranium). The node set produced by 
<CODE>ATOMIC_NUMBER</CODE> is implicitly converted to the string value of the 
current <CODE>ATOMIC_NUMBER</CODE> node. This string is then converted into a 
number. </P><PRE><CODE>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;HTML&gt;
    &lt;HEAD&gt;&lt;TITLE&gt;The Transuranium Elements&lt;/TITLE&gt;&lt;/HEAD&gt;
    &lt;BODY&gt;
      &lt;xsl:apply-templates select="ATOM[ATOMIC_NUMBER&gt;92]"/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>XPath provides the standard four arithmetic operators:</P>
<UL>
  <LI><CODE>+</CODE> for addition 
  <LI><CODE>-</CODE> for subtraction 
  <LI><CODE>*</CODE> for multiplication 
  <LI><CODE>div</CODE> for division (the more common <CODE>/</CODE> is already 
  used for other purposes in XPath) </LI></UL>
<P class=GX>For example, <CODE>&lt;xsl:value-of select="2+2"/&gt;</CODE> inserts 
the string "4" into the output document. These operations are more commonly used 
as part of a test. For example, this rule selects those elements whose atomic 
weight is more than twice their atomic number: </P><PRE><CODE>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;HTML&gt;
    &lt;BODY&gt;
      &lt;H1&gt;High Atomic Weight to Atomic Number Ratios&lt;/H1&gt;
      &lt;xsl:apply-templates
        select="ATOM[ATOMIC_WEIGHT &gt; 2 * ATOMIC_NUMBER]"/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This template actually prints the ratio of atomic weight to atomic 
number:</P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="NAME"/&gt;
    &lt;xsl:value-of select="ATOMIC_WEIGHT div ATOMIC_NUMBER"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>XPath also provides the less-familiar <CODE>mod</CODE> binary 
operator, which takes the remainder of two numbers. When used in conjunction 
with <CODE>position()</CODE> this operator lets you perform tasks such as 
outputting every second <CODE>ATOM</CODE> or alternating colors between rows in 
a table. Just define templates that apply different styles when the position mod 
two is one and when it's zero. For example, these two rules use different colors 
for alternate rows of a table: </P><PRE><CODE>   &lt;xsl:template match="ATOM[position() mod 2 = 1]"&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
   &lt;xsl:template match="ATOM[position() mod 2 = 0]"&gt;
       &lt;tr style="color: #666666"&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>You can change the divisor to 3 to apply different styles to every 
third element, to 4 to apply different styles to every fourth element, and so 
forth. </P>
<P class=GX>Finally, XPath includes four functions that operate on numbers:</P>
<UL>
  <LI><CODE>floor()</CODE> returns the greatest integer less than or equal to 
  the number 
  <LI><CODE>ceiling()</CODE> returns the smallest integer greater than or equal 
  to the number 
  <LI><CODE>round()</CODE> rounds the number to the nearest integer 
  <LI><CODE>sum()</CODE> returns the sum of its arguments </LI></UL>
<P class=GX>For example, this template rule estimates the number of neutrons in 
an atom by subtracting the atomic number (the number of protons) from the atomic 
weight (the weighted average over the natural distribution of isotopes of the 
number of neutrons plus the number of protons) and rounding to the nearest 
integer: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="NAME"/&gt;
    &lt;xsl:value-of
     select="round(ATOMIC_WEIGHT - ATOMIC_NUMBER)"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This rule calculates the average atomic weight of all the atoms in 
the table by adding all the atomic weights, and then dividing by the number of 
atoms: </P><PRE><CODE>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;HTML&gt;
    &lt;BODY&gt;
    &lt;H1&gt;Average Atomic Weight&lt;/H1&gt;
      &lt;xsl:value-of
       select="sum(descendant::ATOMIC_WEIGHT)
               div count(descendant::ATOMIC_WEIGHT)"/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H4>Strings</H4>
<P class=GX>A string is a sequence of Unicode characters. Other data types can 
be converted to strings using the <CODE>string()</CODE> function according to 
these rules: </P>
<UL>
  <LI>Node sets are converted to strings by using the value of the first node in 
  the set as calculated by the <CODE>xsl:value-of</CODE> element according to 
  the rules given in Table 17-1. 
  <LI>Result tree fragments are converted by acting as if they're contained in a 
  single element, and then taking the value of that imaginary element. Again, 
  the value of this element is calculated by the <CODE>xsl:value-of</CODE> 
  element according to the rules given in Table 17-1. That is, all the result 
  tree fragment's text (but not markup) is concatenated. 
  <LI>A number is converted to a European-style number string like -12 or 
  3.1415292. 
  <LI>Boolean false is converted to the English word false. Boolean true is 
  converted to the English word true. </LI></UL>
<P class=GX>Besides <CODE>string()</CODE>, XSLT contains 10 functions that 
manipulate strings. These are summarized in Table 17-5. </P>
<P 
style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans; TEXT-ALIGN: center">Table 
17-5: XPath String Functions </P>
<TABLE summary="(unspecified contents)" border=1>
  <COLGROUP>
  <COL width=142>
  <COL width=78>
  <COL width=216></COLGROUP>
  <TBODY>
  <TR>
    <TD vAlign=top>
      <P 
      style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Function: 
      </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Return 
      Type: </P></TD>
    <TD vAlign=top>
      <P style="FONT-WEIGHT: bold; FONT-FAMILY: Arial, Helvetica, sans">Returns: 
      </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>starts-with(</CODE><SPAN 
      class=italic><CODE>main_string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>prefix_string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>Boolean</P></TD>
    <TD vAlign=top>
      <P class=TX>True if <SPAN class=italic><CODE>main_string</CODE></SPAN> 
      starts with <SPAN class=italic><CODE>prefix_string</CODE></SPAN>; false 
      otherwise </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>contains(</CODE><SPAN 
      class=italic><CODE>containing_string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>contained_string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>Boolean</P></TD>
    <TD vAlign=top>
      <P class=TX>True if the <SPAN 
      class=italic><CODE>contained_string</CODE></SPAN> is part of the <SPAN 
      class=italic><CODE>containing_string</CODE></SPAN>; false otherwise 
  </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>substring(</CODE><SPAN 
      class=italic><CODE>string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>offset, length</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX><SPAN class=italic><CODE>length</CODE></SPAN> characters from 
      the specified <SPAN class=italic><CODE>offset</CODE></SPAN> in <SPAN 
      class=italic><CODE>string</CODE></SPAN>; or all characters from the <SPAN 
      class=italic><CODE>offset</CODE></SPAN> to the end of the <SPAN 
      class=italic><CODE>string</CODE></SPAN> if <SPAN 
      class=italic><CODE>length</CODE></SPAN> is omitted; <SPAN 
      class=italic><CODE>length</CODE></SPAN> and <SPAN 
      class=italic><CODE>offset</CODE></SPAN> are rounded to the nearest integer 
      if necessary </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>substring-before(</CODE><SPAN 
      class=italic><CODE>string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>marker-string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX>The part of the <SPAN class=italic><CODE>string</CODE></SPAN> 
      from the first character up to (but not including) the first occurrence of 
      <SPAN class=italic><CODE>marker-string</CODE></SPAN></P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>substring-after(</CODE><SPAN 
      class=italic><CODE>string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>marker-string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX>The part of the <SPAN class=italic><CODE>string</CODE></SPAN> 
      from the end of the first occurrence of <SPAN 
      class=italic><CODE>marker-string</CODE></SPAN> to the end of <SPAN 
      class=italic><CODE>string</CODE></SPAN>; the first character in the string 
      is at offset 1 </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>string-length(</CODE><SPAN 
      class=italic><CODE>string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>Number</P></TD>
    <TD vAlign=top>
      <P class=TX>The number of characters in <SPAN 
      class=italic><CODE>string</CODE></SPAN></P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>normalize-space(</CODE><SPAN 
      class=italic><CODE>string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX>The <SPAN class=italic><CODE>string</CODE></SPAN> after 
      leading and trailing white space is stripped and runs of white space are 
      replaced with a single space; if the argument is omitted the string value 
      of the context node is normalized </P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>translate(</CODE><SPAN 
      class=italic><CODE>string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>replaced_text</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>replacement_text</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX>Returns <SPAN class=italic><CODE>string</CODE></SPAN> with 
      occurrences of characters in <SPAN 
      class=italic><CODE>replaced_text</CODE></SPAN> replaced by the 
      corresponding characters from <SPAN 
      class=italic><CODE>replacement_text</CODE></SPAN></P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>concat(</CODE><SPAN class=italic><CODE>string1, string2, 
      . . . </CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX>Returns the concatenation of as many strings as are passed as 
      arguments in the order they were passed</P></TD></TR>
  <TR>
    <TD vAlign=top>
      <P class=TX><CODE>format-number(</CODE><SPAN 
      class=italic><CODE>number</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>format-string</CODE></SPAN><CODE>, </CODE><SPAN 
      class=italic><CODE>locale-string</CODE></SPAN><CODE>)</CODE></P></TD>
    <TD vAlign=top>
      <P class=TX>String</P></TD>
    <TD vAlign=top>
      <P class=TX>Returns the string form of <SPAN 
      class=italic><CODE>number</CODE></SPAN> formatted according to the 
      specified <SPAN class=italic><CODE>format-string</CODE></SPAN> as if by 
      Java 1.1's<SPAN class=italic><CODE> 
      </CODE></SPAN><CODE>java.text.DecimalFormat</CODE> class (see 
      <CODE>http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html</CODE>); 
      the <SPAN class=italic><CODE>locale-string</CODE></SPAN> is an optional 
      argument that provides the name of the <CODE>xsl:decimal-format</CODE> 
      element used to interpret the <SPAN 
      class=italic><CODE>format-string</CODE></SPAN></P></TD></TR></TBODY></TABLE>
<H4>Result tree fragments</H4>
<P class=GX>A result tree fragment is a portion of an XML document that is not a 
complete node or set of nodes. For instance, using the <CODE>document()</CODE> 
function with a URI that points into the middle of an element might produce a 
result tree fragment. Result tree fragments may also be returned by some 
extension functions (functions unique to a particular XSLT implementation or 
installation). </P>
<P class=GX>Because result tree fragments aren't well-formed XML, you can't do 
much with them. In fact, the only allowed operations are to convert them to a 
string or a boolean using <CODE>string()</CODE> and <CODE>boolean()</CODE>, 
respectively. </P>
<H2><A name=d1e6203>The Default Template Rules</A></H2>
<P class=GX>Having to carefully map the hierarchy of an XML document in an XSLT 
style sheet may be inconvenient. This is especially true if the document does 
not follow a stable, predictable order like the periodic table, but rather 
throws elements together willy-nilly like many Web pages. In those cases, you 
should have general rules that can find an element and apply templates to it 
regardless of where it appears in the source document. </P>
<P class=GX>To make this process easier, XSLT defines several default template 
rules that are implicitly included in all style sheets. The first default rule 
matches root and element nodes, and applies templates to all child nodes. The 
second default rule matches text nodes and attributes, copying their values onto 
the output stream. Together these two rules mean that even a blank XSLT style 
sheet with just one empty <CODE>xsl:stylesheet</CODE> element will still produce 
the raw character data of the input XML document as output. </P>
<H3>The default rule for elements</H3>
<P class=GX>The first default rule applies to element nodes and the root 
node:</P><PRE><CODE>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX><CODE>*|/</CODE> is XPath shorthand for "any element node or the 
root node." The purpose of this rule is to ensure that all elements are 
recursively processed even if they aren't reached by following the explicit 
rules. That is, unless another rule overrides this one (especially for the root 
element), all element nodes will be processed. </P>
<P class=GX>However, once an explicit rule for any parent of an element is 
present, this rule will not be activated for the child elements unless the 
template rule for the parent has an <CODE>xsl:apply-templates</CODE> child. For 
instance, you can stop all processing by matching the root element and neither 
applying templates nor using <CODE>xsl:for-each</CODE> to process the children 
like this: </P><PRE><CODE>&lt;xsl:template match="/"&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>The default rule for text nodes and attributes</H3>
<P class=GX>Exceptionally observant readers may have noted several of the 
examples seem to have output the contents of some elements without actually 
taking the value of the element they were outputting! These contents were 
provided by XSLT's default rule for text and attribute nodes. This rule is: </P><PRE><CODE>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This rule matches all text and attribute nodes 
(<CODE>match="text()</CODE>|<CODE>@*"</CODE>) and outputs the value of the node 
(<CODE>&lt;xsl:value-of select="."/&gt;</CODE>). In other words, it copies the 
text from the input to the output. This rule ensures that at the very least an 
element's text is output, even if no rule specifically matches it. Another rule 
can override this one for specific elements where you want either more or less 
than the text content of an element. </P>
<P class=GX>This rule also copies attribute values (but not names). However, 
they turn from attributes in the input to simple text in the output. Because 
there's no default rule that ever applies templates to attributes, this rule 
won't be activated for attributes unless you specifically add a nondefault rule 
somewhere in the style sheet that does apply templates to attributes of one or 
more elements. </P>
<H3>The default rule for processing instructions and comments</H3>
<P class=GX>There's also a default rule for processing instructions and 
comments. It simply says to do nothing; that is, drop the processing 
instructions and comments from the output as if they didn't exist. It looks like 
this: </P><PRE><CODE>&lt;xsl:template match="processing-instruction()|comment()"/&gt;
</CODE></PRE>
<P class=GX>You can, of course, replace this with your own rule for handling 
processing instructions and comments if you want to.</P>
<H3>Implications of the default rules</H3>
<P class=GX>Together, the default rules imply that applying an empty style sheet 
with only an <CODE>xsl:stylesheet</CODE> or <CODE>xsl:transform</CODE> element 
but no children (such as Listing 17-14) to an XML document copies all the 
<CODE>#PCDATA</CODE> out of the elements in the input to the output. However, 
this method produces no markup. These are, however, extremely low priority 
rules. Consequently, any other matches take precedence over the default rules. 
</P>
<P style="FONT-WEIGHT: bold">Listing 17-14: An empty XML style sheet </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Caution</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">One 
of the most common sources of confusion about XSLT in Internet Explorer 5.5 and 
earlier is that IE does not provide any of these default rules. You have to make 
sure that you explicitly match any node whose contents (including descendants) 
you want to output. </P>
<H2><A name=d1e6328>Deciding What Output to Include</A></H2>
<P class=GX>It's often necessary to defer decisions about what markup to emit 
until the input document has been read. For instance, you may want to change the 
contents of a <CODE>FILENAME</CODE> element into the <CODE>HREF</CODE> attribute 
of an <CODE>A</CODE> element, or replace one element type in the input with 
several different element types in the output depending on the value of an 
attribute. This is accomplished with <CODE>xsl:element</CODE>, 
<CODE>xsl:attribute</CODE>, <CODE>xsl:processing-instruction</CODE>, 
<CODE>xsl:comment</CODE>, and <CODE>xsl:text</CODE> elements. XSLT instructions 
are used in the contents of these elements and attribute value templates are 
used in the attribute values of these elements to vary their output. </P>
<H3>Attribute value templates</H3>
<P class=GX>Attribute value templates copy data from the input document to 
attribute values in the output. For example, suppose you want to convert the 
periodic table into empty <CODE>ATOM</CODE> elements with this attribute-based 
form: </P><PRE><CODE>&lt;ATOM NAME="Vanadium"
  ATOMIC_WEIGHT="50.9415"
  ATOMIC_NUMBER="23"
/&gt;
</CODE></PRE>
<P class=GX>To do this, you need to extract the contents of elements in the 
input document and place those in attribute values in the output document. The 
first thing you're likely to attempt is something similar to this: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;ATOM NAME="&lt;xsl:value-of select='NAME'/&gt;"
    ATOMIC_WEIGHT="&lt;xsl:value-of select='ATOMIC_WEIGHT'/&gt;"
    ATOMIC_NUMBER="&lt;xsl:value-of select='ATOMIC_NUMBER'/&gt;"
  /&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>But this is malformed XML. You can't use the <CODE>&lt;</CODE> 
character inside an attribute value. Furthermore, it's extremely difficult to 
write software that can parse this in its most general case. </P>
<P class=GX>Instead, inside attribute values, data enclosed in curly braces 
<CODE>{}</CODE> takes the place of the <CODE>xsl:value-of</CODE> element. The 
correct way to write the above template is like this: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;ATOM NAME="{NAME}"/&gt;
    ATOMIC_WEIGHT="{ATOMIC_WEIGHT}"
    ATOMIC_NUMBER="{ATOMIC_NUMBER}"
  /&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>In the output, <CODE>{NAME}</CODE> is replaced by the value of the 
<CODE>NAME</CODE> child element of the matched <CODE>ATOM</CODE>. 
<CODE>{ATOMIC_WEIGHT}</CODE> is replaced by the value of the 
<CODE>ATOMIC_WEIGHT</CODE> child element of the matched <CODE>ATOM</CODE>. 
<CODE>{ATOMIC_NUMBER}</CODE> is replaced by the value of the 
<CODE>ATOMIC_NUMBER</CODE> child element, and so on. </P>
<P class=GX>Attribute value templates can have more complicated patterns than 
merely an element name. In fact, you can use any XPath expression in an 
attribute value template. For example, this template rule selects 
<CODE>DENSITY</CODE> elements in the form used in Listing 17-1. </P><PRE><CODE>&lt;xsl:template match="DENSITY"&gt;
  &lt;BULK_PROPERTY
    NAME="DENSITY"
    ATOM="{../NAME}"
    VALUE="{normalize-space(.)}"
    UNITS="{@UNITS}"
  /&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>It converts them into <CODE>BULK_PROPERTY</CODE> elements that look 
like this: </P><PRE><CODE>&lt;BULK_PROPERTY NAME="DENSITY" ATOM="Helium"
  VALUE="0.0001785" UNITS="grams/cubic centimeter"/&gt;
</CODE></PRE>
<P class=GX>Attribute values are not limited to a single attribute value 
template. You can combine an attribute value template with literal data or with 
other attribute value templates. For example, this template rule matches 
<CODE>ATOM</CODE> elements and replaces them with their name formatted as a link 
to a file in the format H.html, He.html, and so on. The filename is derived from 
the attribute value template <CODE>{SYMBOL}</CODE>, while the literal data 
provides the period and extension. </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;A HREF="{SYMBOL}.html"&gt;
    &lt;xsl:value-of select="NAME"/&gt;
  &lt;/A&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>More than one attribute value template can be included in an 
attribute value. For example, this template rule includes the density units as 
part of the <CODE>VALUE</CODE> attribute rather than making them a separate 
attribute: </P><PRE><CODE>&lt;xsl:template match="DENSITY"&gt;
  &lt;BULK_PROPERTY
    NAME="DENSITY"
    ATOM="{../NAME}"
    VALUE="{normalize-space(.)} {@UNITS}"
  /&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>You can use attribute value templates in many attributes in an XSLT 
style sheet. This is particularly important in <CODE>xsl:element</CODE>, 
<CODE>xsl:attribute</CODE>, and <CODE>xsl:processing-instruction</CODE> elements 
where attribute value templates allow the designer to defer the decision about 
exactly what element, attribute, or processing instruction appears in the output 
until the input document is read. You cannot use attribute value templates as 
the value of a <CODE>select</CODE> or <CODE>match</CODE> attribute, an 
<CODE>xmlns</CODE> attribute, an attribute that provides the name of another 
XSLT instruction element, or an attribute of a top-level element (one that's an 
immediate child of <CODE>xsl:stylesheet</CODE>). </P>
<H3>Inserting elements into the output with xsl:element</H3>
<P class=GX>Elements are usually included in the output document simply by 
including the literal start and end tags in template content. For instance, to 
insert a <CODE>P</CODE> element you merely type <CODE>&lt;P&gt;</CODE> and 
<CODE>&lt;/P&gt;</CODE> at the appropriate points in the style sheet. However, 
occasionally you need to use details from the input document to determine which 
element to place in the output document. This might happen, for example, when 
making a transformation from a source vocabulary that uses attributes for 
information to an output vocabulary that uses elements for the same information. 
</P>
<P class=GX>The <CODE>xsl:element</CODE> element inserts an element into the 
output document. The name of the element is given by an attribute value template 
in the <CODE>name</CODE> attribute of <CODE>xsl:element</CODE>. The content of 
the element derives from the content of the <CODE>xsl:element</CODE> element, 
which may include <CODE>xsl:attribute</CODE>, 
<CODE>xsl:processing-instruction,</CODE> and <CODE>xsl:comment</CODE> 
instructions (all discussed below) to insert these items. </P>
<P class=GX>For example, suppose you want to replace the <CODE>ATOM</CODE> 
elements with <CODE>GAS</CODE>, <CODE>LIQUID</CODE>, and <CODE>SOLID</CODE> 
elements, depending on the value of the <CODE>STATE</CODE> attribute. Using 
<CODE>xsl:element</CODE>, a single rule can do this by converting the value of 
the <CODE>STATE</CODE> attribute to an element name. This is how it works: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:element name="{@STATE}"&gt;
    &lt;NAME&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/NAME&gt;
    &lt;!-- rules for other children --&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>By using more complicated attribute value templates, you can perform 
most of the calculations that you might need.</P>
<H3>Inserting attributes into the output with xsl:attribute</H3>
<P class=GX>You can include attributes in the output document simply by typing 
the literal attributes themselves. For instance, to insert a <CODE>DIV</CODE> 
element with an <CODE>ALIGN</CODE> attribute bearing the value 
<CODE>CENTER</CODE>, you merely type <CODE>&lt;DIV ALIGN="CENTER"&gt;</CODE> and 
<CODE>&lt;/DIV&gt;</CODE> at the appropriate points in the style sheet. However, 
you frequently have to rely on data that you read from the input document to 
determine an attribute value and sometimes even to determine the attribute name. 
</P>
<P class=GX>For example, suppose you want a style sheet that selects atom names 
and formats them as links to files named H.html, He.html, Li.html, and so forth 
like this: </P><PRE><CODE>&lt;LI&gt;&lt;A HREF="H.html"&gt;Hydrogen&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="He.html"&gt;Helium&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="Li.html"&gt;Lithium&lt;/A&gt;&lt;/LI&gt;
</CODE></PRE>
<P class=GX>Each different element in the input will have a different value for 
the <CODE>HREF</CODE> attribute. The <CODE>xsl:attribute</CODE> element 
calculates an attribute name and value and inserts it into the output. Each 
<CODE>xsl:attribute</CODE> element is a child of either an 
<CODE>xsl:element</CODE> element or a literal element. The attribute calculated 
by <CODE>xsl:attribute</CODE> will be attached to the element calculated by its 
parent in the output. The name of the attribute is specified by the 
<CODE>name</CODE> attribute of the <CODE>xsl:attribute</CODE> element. The value 
of the attribute is given by the contents of the <CODE>xsl:attribute</CODE> 
element. For example, this template rule produces the output shown above: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;LI&gt;&lt;A&gt;
    &lt;xsl:attribute name="HREF"&gt;
      &lt;xsl:value-of select="SYMBOL"/&gt;.html
    &lt;/xsl:attribute&gt;
    &lt;xsl:value-of select="NAME"/&gt;
  &lt;/A&gt;&lt;/LI&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>All <CODE>xsl:attribute</CODE> elements must come before any other 
content of their parent element. You can't add an attribute to an element after 
you've already started writing out its content. For example, this template is 
illegal: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;LI&gt;&lt;A&gt;
    &lt;xsl:value-of select="NAME"/&gt;
    &lt;xsl:attribute name="HREF"&gt;
      &lt;xsl:value-of select="SYMBOL"/&gt;.html
    &lt;/xsl:attribute&gt;
  &lt;/A&gt;&lt;/LI&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H3>Defining attribute sets</H3>
<P class=GX>You often need to apply the same group of attributes to many 
different elements, of either the same or different classes. For instance, you 
might want to apply a <CODE>style</CODE> attribute to each cell in an HTML 
table. To make this simpler, you can define one or more attributes as members of 
an attribute set at the top level of the style sheet with 
<CODE>xsl:attribute-set</CODE>, and then include that attribute set in an 
element with an <CODE>xsl:use-attribute-sets</CODE> attribute. </P>
<P class=GX>For example, this <CODE>xsl:attribute-set</CODE> element defines an 
element named <CODE>cellstyle</CODE> with a <CODE>font-family</CODE> attribute 
of <CODE>New York</CODE>, <CODE>Times</CODE> <CODE>New Roman</CODE>, 
<CODE>Times</CODE>, <CODE>serif</CODE> and a <CODE>font-size</CODE> attribute of 
<CODE>12pt</CODE>. </P><PRE><CODE>&lt;xsl:attribute-set name="cellstyle"&gt;
  &lt;xsl:attribute name="font-family"&gt;
    New York, Times New Roman, Times, serif
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
</CODE></PRE>
<P class=GX>This template rule then applies those attributes to <CODE>td</CODE> 
elements in the output. </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;tr&gt;
    &lt;td xsl:use-attribute-sets="cellstyle"&gt;
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/td&gt;
    &lt;td xsl:use-attribute-sets="cellstyle"&gt;
      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>An element can use more than one attribute set by specifying the 
names of the all the sets in a white space separated list in the value of the 
<CODE>xsl:use-attribute-sets</CODE> attribute. All attributes from all the sets 
are applied to the element. For example, this <CODE>td</CODE> element possesses 
attributes from both the <CODE>cellstyle</CODE> and the <CODE>numberstyle</CODE> 
attribute sets. </P><PRE><CODE>    &lt;td xsl:use-attribute-sets="cellstyle numberstyle"&gt;
      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;
    &lt;/td&gt;
</CODE></PRE>
<P class=GX>If more than one attribute set defines the same attribute, then the 
last attribute set mentioned is used. If there is more than one attribute set 
with the same name (as may happen when one style sheet imports another) then the 
attributes in the sets are merged. If the identically named attribute sets 
define the same attribute, then the value from the set with higher importance is 
chosen. A style sheet in which multiple attribute sets of the same importance 
with the same name define the same attribute is in error. </P>
<P class=GX>You can also include attribute sets in particular elements by adding 
a <CODE>use-attribute-sets</CODE> element to an <CODE>xsl:element</CODE>, 
<CODE>xsl:copy</CODE>, or <CODE>xsl:attribute-set</CODE> element. For example, 
</P><PRE><CODE>    &lt;xsl:element name="td" use-attribute-sets="cellstyle"&gt;
      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;
    &lt;/xsl:element&gt;
</CODE></PRE>
<P class=GX>The <CODE>xsl:</CODE> prefix is unnecessary (and in fact prohibited) 
when <CODE>use-attribute-sets</CODE> is an attribute of an XSLT element rather 
than an element from the result set. </P>
<H3>Generating processing instructions with xsl:processing-instruction</H3>
<P class=GX>The <CODE>xsl:processing-instruction</CODE> element places a 
processing instruction in the output document. The target of the processing 
instruction is specified by a required <CODE>name</CODE> attribute. The contents 
of the <CODE>xsl:processing-instruction</CODE> element become the contents of 
the processing instruction. For example, this rule replaces <CODE>PROGRAM</CODE> 
elements with a <CODE>gcc</CODE> processing instruction: </P><PRE><CODE>&lt;xsl:template match="PROGRAM"&gt;
  &lt;xsl:processing-instruction name="gcc"&gt; -O4
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX><CODE>PROGRAM</CODE> elements in the input are replaced by this 
processing instruction in the output: </P><PRE><CODE>&lt;?gcc -O4
  ?&gt;
</CODE></PRE>
<P class=GX>The contents of the <CODE>xsl:processing-instruction</CODE> element 
can include <CODE>xsl:value-of</CODE> elements and 
<CODE>xsl:apply-templates</CODE> elements provided the result of these 
instructions is pure text. For example, </P><PRE><CODE>&lt;xsl:template match="PROGRAM"&gt;
  &lt;xsl:processing-instruction name="gcc"&gt;-O4 
    &lt;xsl:value-of select="NAME"/&gt;
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>xsl:processing-instruction</CODE> element may not contain 
<CODE>xsl:element</CODE> and other instructions that produce elements and 
attributes in the result. Furthermore, <CODE>xsl:processing-instruction</CODE> 
may not include any instructions or literal text that insert a 
<CODE>?&gt;</CODE> in the output because that would prematurely end the 
processing instruction. </P>
<H3>Generating comments with xsl:comment</H3>
<P class=GX>The <CODE>xsl:comment</CODE> element inserts a comment in the output 
document. It has no attributes. Its contents are the text of the comment. For 
example, </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:comment&gt;There was an atom here once.&lt;/xsl:comment&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This rule replaces <CODE>ATOM</CODE> nodes with this comment: </P><PRE><CODE>&lt;!--There was an atom here once.--&gt;
</CODE></PRE>
<P class=GX>The contents of the <CODE>xsl:comment</CODE> element can include 
<CODE>xsl:value-of</CODE> elements and <CODE>xsl:apply-templates</CODE> elements 
provided the results of these instructions are pure text. It may not contain 
<CODE>xsl:element</CODE> and other instructions that produce elements and 
attributes in the result. Furthermore, <CODE>xsl:comment</CODE> may not include 
any instructions or literal text that inserts a double hyphen in the comment. 
This would result in a malformed comment in the output. </P>
<H3>Generating text with xsl:text</H3>
<P class=GX>The <CODE>xsl:text</CODE> element inserts its contents into the 
output document as literal text. For example, this rule replaces each 
<CODE>ATOM</CODE> element with the string "There was an atom here once." </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:text&gt;There was an atom here once.&lt;/xsl:text&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>xsl:text</CODE> element isn't much used because most of 
the time it's easier to simply type the text. However, <CODE>xsl:text</CODE> 
does have a couple of advantages. The first is that it preserves white space 
exactly, even if the node contains nothing but white space. By default, XSLT 
processors delete all text nodes from the style sheet that contain only white 
space. This is useful when dealing with poetry, computer source code, or other 
text in which white space is significant. </P>
<P class=GX>The second advantage is that it enables you to insert unescaped 
<CODE>&lt;</CODE> and <CODE>&amp;</CODE> into your output document that are not 
converted to <CODE>&amp;lt;</CODE> and <CODE>&amp;amp;</CODE>. To do this, place 
the general entity reference for the symbol (<CODE>&amp;lt;</CODE> or 
<CODE>&amp;amp;</CODE>) in an <CODE>xsl:text</CODE> element; then set the 
<CODE>xsl:text</CODE> element's <CODE>disable-output-escaping</CODE> attribute 
to <CODE>yes</CODE>. This can be useful when you need to include JavaScript 
source code in the output document. For example, </P><PRE><CODE>&lt;xsl:template match="SCRIPT"&gt;
  &lt;script language="javascript"&gt;
    &lt;xsl:text disable-output-escaping="yes"&gt;
      &amp;lt;!-- if (
         location.host.tolowercase().indexof("ibiblio")
         &amp;lt; 0) {
           location.href="http://www.ibiblio.org/xml/";
        }
      } // --&amp;gt;
    &lt;/xsl:text&gt;
  &lt;/script&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This may produce output that is not well-formed XML. (Indeed that's 
the case here.) However, if you're trying to write a non-XML format such as HTML 
or TeX this may be what you want. Note, however, that the style sheet and the 
input document are both still well-formed XML. </P>
<H2><A name=d1e7170>Copying the Context Node with xsl:copy</A></H2>
<P class=GX>The <CODE>xsl:copy</CODE> element copies the source node into the 
output tree. Child elements, attributes, and other content are not automatically 
copied. However, the contents of the <CODE>xsl:copy</CODE> element are an 
<CODE>xsl:template</CODE> element that can select these things to be copied as 
well. This is often useful when transforming a document from one markup 
vocabulary to the same or a closely related markup vocabulary. For example, this 
template rule strips the attributes and child elements off an <CODE>ATOM</CODE> 
and replaces it with the value of its contents enclosed in a <CODE>b</CODE> 
element: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
   &lt;xsl:copy&gt;
     &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>One useful template <CODE>xsl:copy</CODE> makes possible is the 
identity transformation; that is, a transformation from a document into itself. 
Such a transformation looks like this: </P><PRE><CODE>&lt;xsl:template 
  match="*|@*|comment()|processing-instruction()|text()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates
     select="*|@*|comment()|processing-instruction()|text()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>You can adjust the identity transformation a little to produce 
similar documents. For example, Listing 17-15 is a style sheet that strips 
comments from a document, leaving the document otherwise untouched. It resulted 
from leaving the <CODE>comment()</CODE> node out of the <CODE>match</CODE> and 
<CODE>select</CODE> attribute values in the identity transformation. </P>
<P style="FONT-WEIGHT: bold">Listing 17-15: An XSLT style sheet that strips 
comments from a document </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template 
     match="*|@*|processing-instruction()|text()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates
        select="*|@*|processing-instruction()|text()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX><CODE>xsl:copy</CODE> only copies the source node. You can copy 
other nodes, possibly more than one of them, using <CODE>xsl:copy-of</CODE>. The 
<CODE>select</CODE> attribute of <CODE>xsl:copy-of</CODE> chooses the nodes to 
be copied. For example, Listing 17-16 is a style sheet that uses 
<CODE>xsl:copy-of</CODE> to strip out elements without melting points from the 
periodic table by copying only <CODE>ATOM</CODE> elements that have 
<CODE>MELTING_POINT</CODE> children. </P>
<P style="FONT-WEIGHT: bold">Listing 17-16: A style sheet that copies only ATOM 
elements that have MELTING_POINT children </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;PERIODIC_TABLE&gt;
        &lt;xsl:apply-templates select="ATOM"/&gt;
      &lt;/PERIODIC_TABLE&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;xsl:apply-templates select="MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
   &lt;xsl:template match="MELTING_POINT"&gt;
     &lt;xsl:copy-of select=".."/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Note</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Listings 
17-15 and 17-16 are examples of XSL transformations from a source vocabulary to 
the same vocabulary. Unlike most of the examples in this chapter, they do not 
transform to well-formed HTML. </P>
<H2><A name=d1e7364>Counting Nodes with xsl:number</A></H2>
<P class=GX>The <CODE>xsl:number</CODE> element inserts a formatted integer into 
the output document. The value of the integer is given by the <CODE>value</CODE> 
attribute. This contains a number, which is rounded to the nearest integer, then 
formatted according to the value of the <CODE>format</CODE> attribute. 
Reasonable defaults are provided for both these attributes. For example, 
consider the style sheet for the <CODE>ATOM</CODE> elements in Listing 17-17. 
</P>
<P style="FONT-WEIGHT: bold">Listing 17-17: An XSLT style sheet that counts 
atoms </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;head&gt;&lt;title&gt;The Elements&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;table&gt;
            &lt;tr&gt;&lt;xsl:apply-templates select="ATOM"/&gt;&lt;/tr&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;td&gt;&lt;xsl:number value="ATOMIC_NUMBER"/&gt;&lt;/td&gt;    
      &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>When this style sheet is applied to Listing 17-1, the output appears 
like this:</P><PRE><CODE>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Elements&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</CODE></PRE>
<P class=GX>Each element is matched with its atomic number. The 
<CODE>value</CODE> attribute can contain any data that XPath knows how to 
convert to a number. In this case, the <CODE>ATOMIC_NUMBER</CODE> child element 
of the matched <CODE>ATOM</CODE> is converted. </P>
<H3>Default numbers</H3>
<P class=GX>If you use the <CODE>value</CODE> attribute to calculate the number, 
that's all you need. However, if the <CODE>value</CODE> attribute is omitted, 
then the position of the current node in the source tree is used as the number. 
For example, consider Listing 17-18, which produces a table of atoms that have 
boiling points less than or equal to the boiling point of nitrogen. </P>
<P style="FONT-WEIGHT: bold">Listing 17-18: An XSLT style sheet that counts 
atoms </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;head&gt;&lt;title&gt;The Elements&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td&gt;Name&lt;/td&gt;
              &lt;td&gt;Position&lt;/td&gt;
              &lt;td&gt;Default Number&lt;/td&gt;
              &lt;td&gt;Boiling Point&lt;/td&gt;
            &lt;/tr&gt;
            &lt;xsl:apply-templates 
              select="ATOM[BOILING_POINT &amp;lt;= 77.344]"/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:number value="position()"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:number/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:number value="BOILING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Figure 17-5 shows the finished table produced by applying this 
stylesheet to the complete periodic table. This shows that the default value 
calculated by <CODE>xsl:number</CODE> is the position of the node among other 
sibling nodes of the same type (<CODE>ATOM</CODE> elements in this case) . This 
is not the same as the number returned by the <CODE>position()</CODE> function, 
which only calculates position relative to other nodes in the context node list 
(the nodes which the template matched — hydrogen, helium, nitrogen, and neon in 
this example). You can change what <CODE>xsl:number</CODE> counts using these 
three attributes: </P>
<UL>
  <LI><CODE>level</CODE> 
  <LI><CODE>count</CODE> 
  <LI><CODE>from</CODE> </LI></UL>
<DIV align=center><IMG height=145 alt="Image: 17/picture9.jpg" 
src="XSL Transformations_files/picture9.jpg" width=240></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-5: Atoms with boiling points less than or 
equal to nitrogen's </P>
<H4>The level attribute</H4>
<P class=GX>By default, with no <CODE>value</CODE> attribute, 
<CODE>xsl:number</CODE> counts siblings of the source node with the same type. 
For instance, if the <CODE>ATOMIC_NUMBER</CODE> elements were numbered instead 
of <CODE>ATOM</CODE> elements, none would have a number higher than 1 because an 
<CODE>ATOM</CODE> never has more than one <CODE>ATOMIC_NUMBER</CODE> child. 
Although the document contains more than one <CODE>ATOMIC_NUMBER</CODE> element, 
these are not siblings. </P>
<P class=GX>Setting the <CODE>level</CODE> attribute of <CODE>xsl:number</CODE> 
to <CODE>any</CODE> counts all of the elements of the same kind as the current 
node in the document. This includes not just the ones in the current node list, 
but all nodes of the same type. Even if you select only the atomic numbers of 
the gases, for example, the solids and liquids would still count, even if they 
weren't output. Consider these rules: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;tr&gt;&lt;xsl:apply-templates select="NAME"/&gt;&lt;/tr&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="NAME"&gt;
  &lt;td&gt;&lt;xsl:number level="any"/&gt;&lt;/td&gt;
  &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Because <CODE>level</CODE> is set to <CODE>any</CODE>, these 
templates produce output like this that doesn't start from 1 with each new 
<CODE>NAME</CODE> element: </P><PRE><CODE>&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
&lt;/tr&gt;
</CODE></PRE>
<P class=GX>If you remove the <CODE>level</CODE> attribute or set it to its 
default value of <CODE>single</CODE>, then the output looks like this: </P><PRE><CODE>&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
&lt;/tr&gt;
</CODE></PRE>
<P class=GX>A slightly less useful option sets the <CODE>level</CODE> attribute 
of <CODE>xsl:number</CODE> to <CODE>multiple</CODE> to specify that both the 
siblings of the current node and its ancestors (but not their children that 
aren't siblings of the current node) should be counted. </P>
<H4>The count attribute</H4>
<P class=GX>By default, with no <CODE>value</CODE> attribute, only elements of 
the same type as the element of the current node get counted. However, you can 
set the <CODE>count</CODE> attribute of <CODE>xsl:number</CODE> to an expression 
that specifies what to count. For instance, this rule matches all the child 
elements of an <CODE>ATOM</CODE>. It places a number in front of each one that 
represents its position among all the children of that <CODE>ATOM</CODE>. </P><PRE><CODE>&lt;xsl:template match="ATOM/*"&gt;
  &lt;td&gt;&lt;xsl:number count="*"/&gt;&lt;/td&gt;
  &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The output from this template looks like this:</P><PRE><CODE>    &lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;&lt;td&gt;H&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;&lt;td&gt;1.00794&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;&lt;td&gt;20.28&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;&lt;td&gt;13.81&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;&lt;td&gt;
      0.0000899
    &lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;&lt;td&gt;He&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;&lt;td&gt;4.0026&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;&lt;td&gt;4.216&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;&lt;td&gt;0.95&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;&lt;td&gt;
      0.0001785
    &lt;/td&gt;
</CODE></PRE>
<H4>The from attribute</H4>
<P class=GX>The <CODE>from</CODE> attribute contains an XPath expression that 
specifies which element the counting begins with in the input tree. However, the 
counting still begins from 1, not 2 or 10 or some other number. The 
<CODE>from</CODE> attribute only changes which element is considered to be the 
first element. This attribute is only considered when <CODE>level="any"</CODE>. 
Other times it has no effect. </P>
<H3>Number to string conversion</H3>
<P class=GX>Until now, I've implicitly assumed that numbers looked like 1, 2, 3, 
and so on; that is, a European numeral starting from 1 and counting by 1. 
However, that's not the only possibility. For instance, the page numbers in the 
preface and other front matter of books often appear in small Roman numerals 
like i, ii, iii, iv, and so on. And different countries use different 
conventions to group the digits, separate the integer and fractional parts of a 
real number, and represent the symbols for the various digits. These are all 
adjustable through four attributes of <CODE>xsl:number</CODE>: </P>
<UL>
  <LI><CODE>format</CODE> 
  <LI><CODE>letter-value</CODE> 
  <LI><CODE>grouping-separator</CODE> 
  <LI><CODE>grouping-size</CODE> </LI></UL>
<H4>The format attribute</H4>
<P class=GX>You can adjust the numbering style used by <CODE>xsl:number</CODE> 
using the <CODE>format</CODE> attribute. This attribute generally has one of the 
following values: </P>
<UL>
  <LI><CODE>i</CODE>: the lowercase Roman numerals i, ii, iii, iv, v, vi, . . . 
  <LI><CODE>I</CODE>: the uppercase Roman numerals I, II, III, IV, V, VI, . . . 
  <LI><CODE>a</CODE>: the lowercase letters a, b, c, d, e, f, . . . 
  <LI><CODE>A</CODE>: the uppercase letters A, B, C, D, E, F, . . . </LI></UL>
<P class=GX>For example, this rule numbers the atoms with capital Roman 
numerals:</P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;P&gt;
    &lt;xsl:number value="position()" format="I"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/P&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>You can specify decimal numbering with leading zeroes by including 
the number of leading zeroes you want in the <CODE>format</CODE> attribute. For 
instance, setting <CODE>format="01"</CODE>, produces the sequence 01, 02, 03, 
04, 05, 06, 07, 08, 09, 10, 11, 12, . . . . You might find this useful when 
lining numbers up in columns. </P>
<H4>The letter-value attribute</H4>
<P class=GX>The <CODE>letter-value</CODE> attribute distinguishes between 
letters interpreted as numbers and letters interpreted as letters. For instance, 
if you want to use <CODE>format="I"</CODE> to start the sequence I, J, K, L, M, 
N, . . . instead of I, II, III, IV, V, VI, . . . you would set the 
<CODE>letter-value</CODE> attribute to the keyword <CODE>alphabetic</CODE>. The 
keyword <CODE>traditional</CODE> specifies a numeric sequence. For example, </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;P&gt;
   &lt;xsl:number value="position()"
               format="I" letter-value="alphabetic"/&gt;
   &lt;xsl:value-of select="."/&gt;
  &lt;/P&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H4>Grouping attributes</H4>
<P class=GX>In the United States, we tend to write large numbers with commas 
grouping every three digits; for example, 4,567,302,000. However, in many 
languages and countries, a period or a space separates the groups instead; for 
instance, 4.567.302.000 or 4 567 302 000. Furthermore, in some countries it's 
customary to group large numbers every four digits instead of every three; for 
example, 4,5673,0000. If you're dealing with very long lists that may contain a 
thousand or more items, you need to worry about these issues. </P>
<P class=GX>The <CODE>grouping-separator</CODE> attribute specifies the grouping 
separator used between groups of digits. The <CODE>grouping-size</CODE> 
attribute specifies the number of digits used in a group. Generally, you'd make 
these attributes contingent on the language. For example, </P><PRE><CODE>&lt;xsl:number grouping-separator=" " grouping-size="3"/&gt;
</CODE></PRE>
<H2><A name=d1e8030>Sorting Output Elements</A></H2>
<P class=GX>The <CODE>xsl:sort</CODE> element sorts the output elements into a 
different order than they appear in the input. An <CODE>xsl:sort</CODE> element 
appears as a child of an <CODE>xsl:apply-templates</CODE> element or 
<CODE>xsl:for-each</CODE> element. The <CODE>select</CODE> attribute of the 
<CODE>xsl:sort</CODE> element defines the key used to sort the element's output 
by <CODE>xsl:apply-templates</CODE> or <CODE>xsl:for-each</CODE>. </P>
<P class=GX>By default, sorting is performed in alphabetical order of the keys. 
If more than one <CODE>xsl:sort</CODE> element is present in a given 
<CODE>xsl:apply-templates</CODE> or <CODE>xsl:for-each</CODE> element, then the 
elements are sorted first by the first key, then by the second key, and so on. 
If any elements still compare equally, they are output in the order they appear 
in the source document. </P>
<P class=GX>For example, suppose you have a file full of <CODE>ATOM</CODE> 
elements arranged alphabetically. To sort by atomic number, you can use the 
style sheet in Listing 17-19. </P>
<P style="FONT-WEIGHT: bold">Listing 17-19: An XSLT style sheet that sorts by 
atomic number </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Atomic Weight&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Atomic Weight&lt;/th&gt;
            &lt;xsl:apply-templates&gt;
              &lt;xsl:sort select="ATOMIC_NUMBER"/&gt;
            &lt;/xsl:apply-templates&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="ATOMIC_WEIGHT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Figure 17-6 shows the limits of alphabetical sorting. Hydrogen, 
atomic number 1, is the first element. However, the second element is not 
helium, atomic number 2, but rather neon, atomic number 10. Although 10 sorts 
after 9 numerically, alphabetically 10 falls before 2. </P>
<DIV align=center><IMG height=333 alt="Image: 17/picture11.jpg" 
src="XSL Transformations_files/picture11.jpg" width=335></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-6: Atoms alphabetically sorted by atomic 
number </P>
<P class=GX>You can, however, adjust the order of the sort by setting the 
optional <CODE>data-type</CODE> attribute to the value <CODE>number</CODE>. For 
example, </P><PRE><CODE>&lt;xsl:sort data-type="number" select="ATOMIC_NUMBER"/&gt;
</CODE></PRE>
<P class=GX>Figure 17-7 shows the elements sorted properly.</P>
<DIV align=center><IMG height=333 alt="Image: 17/picture13.jpg" 
src="XSL Transformations_files/picture13.jpg" width=335></DIV>
<P style="FONT-WEIGHT: bold">Figure 17-7: Atoms numerically sorted by atomic 
number </P>
<P class=GX>You can change the order of the sort from the default ascending 
order to descending by setting the <CODE>order</CODE> attribute to 
<CODE>descending</CODE> like this: </P><PRE><CODE>&lt;xsl:sort order="descending"
          data-type="number"
          select="ATOMIC_NUMBER"/&gt;
</CODE></PRE>
<P class=GX>This sorts the elements from the largest atomic number to the 
smallest so that hydrogen now appears last in the list.</P>
<P class=GX>Alphabetical sorting naturally depends on the alphabet. The 
<CODE>lang</CODE> attribute can set the language of the keys. The value of this 
attribute should be an ISO 639 language code such as <CODE>en</CODE> for 
English. However, processors are not required to know how to sort in all the 
different languages that might be encountered in XML. While English sorting is 
fairly straight-forward, many other languages require much more complicated 
algorithms. Indeed a few languages actually have multiple standard ways of 
sorting based on different criteria. The <CODE>lang</CODE> attribute is ignored 
if <CODE>data-type</CODE> is <CODE>number</CODE>. </P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Cross-Reference</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">These 
are the same values supported by the <CODE>xml:lang</CODE> attribute discussed 
in Chapter 11. </P>
<P class=GX>Finally, you can set the <CODE>case-order</CODE> attribute to one of 
the two values <CODE>upper-first</CODE> or <CODE>lower-first</CODE> to specify 
whether uppercase letters sort before lowercase letters or vice versa. The 
default depends on the language. </P>
<H2><A name=d1e8275>Modes</A></H2>
<P class=GX>Sometimes you want to include the same content from the source 
document in the output document multiple times. That's easy to do simply by 
applying templates multiple times, once in each place where you want the data to 
appear. However, suppose you want the data to be formatted differently in 
different locations? That's a little trickier. </P>
<P class=GX>For example, suppose you want the output of processing the periodic 
table to be a series of 100 links to more detailed descriptions of the 
individual atoms. In this case, the output document would start like this: </P><PRE><CODE>&lt;UL&gt;
&lt;LI&gt;&lt;A HREF="#Ac"&gt;Actinium&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Al"&gt;Aluminum&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Am"&gt;Americium&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Sb"&gt;Antimony&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Ar"&gt;Argon&lt;/A&gt;&lt;/LI&gt;
. . .
</CODE></PRE>
<P class=GX>Later in the document, the actual atom descriptions would appear, 
formatted like this:</P><PRE><CODE>&lt;H3&gt;
&lt;A NAME="H"&gt;Hydrogen&lt;/A&gt;
&lt;/H3&gt;
&lt;P&gt;
    Hydrogen
    H
    1
    1.00794
    20.28
    13.81
      0.0000899
  &lt;/P&gt;
</CODE></PRE>
<P class=GX>This sort of application is common anytime you automatically 
generate a table of contents or an index. The <CODE>NAME</CODE> of the atom must 
be formatted differently in the table of contents than in the body of the 
document. You need two different rules that both apply to the <CODE>ATOM</CODE> 
element at different places in the document. The solution is to give each of the 
different rules a <CODE>mode</CODE> attribute. Then you can choose which 
template to apply by setting the <CODE>mode</CODE> attribute of the 
<CODE>xsl:apply-templates</CODE> element. Listing 17-20 demonstrates. </P>
<P style="FONT-WEIGHT: bold">Listing 17-20: An XSLT style sheet that uses modes 
to format the same data differently in two different places </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/PERIODIC_TABLE"&gt;
    &lt;HTML&gt;
      &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;
      &lt;BODY&gt;
        &lt;H2&gt;Table of Contents&lt;/H2&gt;
        &lt;UL&gt;
          &lt;xsl:apply-templates select="ATOM" mode="toc"/&gt;
        &lt;/UL&gt;
        &lt;H2&gt;The Elements&lt;/H2&gt;
        &lt;xsl:apply-templates select="ATOM" mode="full"/&gt;
      &lt;/BODY&gt;
    &lt;/HTML&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM" mode="toc"&gt;
    &lt;LI&gt;&lt;A&gt;
      &lt;xsl:attribute name="HREF"&gt;#&lt;xsl:value-of
        select="SYMBOL"/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/A&gt;&lt;/LI&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM" mode="full"&gt;
    &lt;H3&gt;&lt;A&gt;
      &lt;xsl:attribute name="NAME"&gt;
        &lt;xsl:value-of select="SYMBOL"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/A&gt;&lt;/H3&gt;
      &lt;P&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>The default template rule for nodes preserves modes. That is, for 
every mode <SPAN class=italic>n</SPAN> you declare in your style sheet, the XSLT 
processor adds one template rule that applies specifically to that mode and 
looks like this: </P><PRE><CODE>&lt;xsl:template match="*|/" mode="<SPAN class=italic>n</SPAN>"&gt;
  &lt;xsl:apply-templates mode="<SPAN class=italic>n</SPAN>"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>As usual, you are free to override this default rule with one of 
your own design.</P>
<H2><A name=d1e8497>Defining Constants with xsl:variable</A></H2>
<P class=GX>Named constants help clean up code. They can replace commonly used 
boilerplate text with a simple name and reference. They can also make it easy to 
adjust boilerplate text that appears in multiple locations by simply changing 
the constant definition. </P>
<P class=GX>The <CODE>xsl:variable</CODE> element defines a named string for use 
elsewhere in the style sheet via an attribute value template. It has a single 
attribute, <CODE>name,</CODE> which provides a name by which the variable can be 
referred to. The contents of the <CODE>xsl:variable</CODE> element provide the 
replacement text. For example, this <CODE>xsl:variable</CODE> element defines a 
variable with the name <CODE>copy01</CODE> and the value <CODE>Copyright 2001 
Elliotte Rusty Harold</CODE>: </P><PRE><CODE>&lt;xsl:variable name="copy01"&gt;
  Copyright 2001 Elliotte Rusty Harold
&lt;/xsl:variable&gt;
</CODE></PRE>
<P class=GX>To access the value of this variable, you prefix a dollar sign to 
the name of the variable. To insert this in an attribute, use an attribute value 
template. For example: </P><PRE><CODE>&lt;BLOCK COPYRIGHT="{$copy01}"&gt;
&lt;/BLOCK&gt;
</CODE></PRE>
<P class=GX>You can use <CODE>xsl:value-of</CODE> to insert the variable's 
replacement text into the output document as text: </P><PRE><CODE>&lt;xsl:value-of select="$copy01"/&gt;
</CODE></PRE>
<P class=GX>The contents of the <CODE>xsl:variable</CODE> can contain markup 
including other XSLT instructions. This means that you can calculate the value 
of a variable based on other information, including the value of other 
variables. However, a variable may not refer to itself recursively, either 
directly or indirectly. For instance, the following example is in error: </P><PRE><CODE>&lt;xsl:variable name="GNU"&gt;
  &lt;xsl:value-of select="$GNU"/&gt;'s not Unix
&lt;/xsl:variable&gt;
</CODE></PRE>
<P class=GX>Similarly, two variables may not refer to each other in a circular 
fashion like this:</P><PRE><CODE>&lt;xsl:variable name="Thing1"&gt;
  Thing1 loves &lt;xsl:value-of select="$Thing2"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="Thing2"&gt;
  Thing2 loves &lt;xsl:value-of select="$Thing1"/&gt;
&lt;/xsl:variable&gt;
</CODE></PRE>
<P class=GX><CODE>xsl:variable</CODE> elements can either be top-level children 
of the <CODE>xsl:stylesheet</CODE> root element or they can be included inside 
template rules. A variable present at the top level of a style sheet can be 
accessed anywhere in the style sheet. It’s a global variable. By contrast, a 
variable that’s declared inside a template rule is only accessible by its 
following sibling elements and their descendants (the <SPAN 
class=italic>scope</SPAN> of the variable). It’s a local variable. Local 
variables override global variables with the same name. Local variables can also 
override other local variables. In the event of a conflict between two variables 
with the same name, the closest local variable with the same name is used. </P>
<H2><A name=d1e8598>Named Templates</A></H2>
<P class=GX>Variables are limited to basic text and markup. XSLT provides a more 
powerful macro facility that can wrap standard markup and text around changing 
data. For example, suppose you want an atom's atomic number, atomic weight, and 
other key values formatted as a table cell in small, bold Times in blue. In 
other words, you want the output to look like this: </P><PRE><CODE>&lt;td&gt;
  &lt;font face="Times, serif" color="blue" size="2"&gt;
    &lt;b&gt;52&lt;/b&gt;
  &lt;/font&gt;
&lt;/td&gt;
</CODE></PRE>
<P class=GX>You can certainly include all that in a template rule like this:</P><PRE><CODE>&lt;xsl:template match="ATOMIC_NUMBER"&gt;
  &lt;td&gt;
    &lt;font face="Times, serif" color="blue" size="2"&gt;
      &lt;b&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/b&gt;
    &lt;/font&gt;
  &lt;/td&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This markup can be repeated inside other template rules. When the 
detailed markup grows more complex, and when it appears in several different 
places in a style sheet, you may elect to turn it into a named template. Named 
templates resemble variables. However, they enable you to include data from the 
place where the template is applied, rather than merely inserting fixed text. 
</P>
<P class=GX>The <CODE>xsl:template</CODE> element can have a <CODE>name</CODE> 
attribute by which it can be explicitly invoked, even when it isn't applied 
indirectly. For example, this shows a sample named template for the above 
pattern: </P><PRE><CODE>&lt;xsl:template name="ATOM_CELL"&gt;
  &lt;td&gt;
    &lt;font face="Times, serif" color="blue" size="2"&gt;
      &lt;b&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/b&gt;
    &lt;/font&gt;
  &lt;/td&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>&lt;xsl:value-of select="."/&gt;</CODE> element in the 
middle of the named template will be replaced by the contents of the current 
node from which this template was called. </P>
<P class=GX>The <CODE>xsl:call-template</CODE> element appears in the contents 
of a template rule. It has a required <CODE>name</CODE> argument that names the 
template it will call. When processed, the <CODE>xsl:call-template</CODE> 
element is replaced by the contents of the <CODE>xsl:template</CODE> element it 
names. For example, you can now rewrite the <CODE>ATOMIC_NUMBER</CODE> rule like 
this by using the <CODE>xsl:call-template</CODE> element to call the 
<CODE>ATOM_CELL</CODE> named template: </P><PRE><CODE>&lt;xsl:template match="ATOMIC_NUMBER"&gt;
  &lt;xsl:call-template name="ATOM_CELL"/&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This fairly simple example only saves a few lines of code, but the 
more complicated the template, and the more times it's reused, the greater the 
reduction in complexity of the style sheet. Named templates also have the 
advantage, like variables, of factoring out common patterns in the style sheet 
so that you can edit them as one. For instance, if you decide to change the 
color of atomic number, atomic weight, and other key values from blue to red, 
you only need to change it once in the named template. You do not have to change 
it in each separate template rule. This facilitates greater consistency of 
style. </P>
<H2><A name=d1e8730>Passing Parameters to Templates</A></H2>
<P class=GX>Each separate invocation of a template can pass parameters to the 
template to customize its output. This is done the same way for named templates 
and unnamed templates. In the <CODE>xsl:template</CODE> element, the parameters 
are represented as <CODE>xsl:param</CODE> child elements. In 
<CODE>xsl:call-template</CODE> or <CODE>xsl:apply-templates</CODE> elements, 
parameters are represented as <CODE>xsl:with-param</CODE> child elements. </P>
<P class=GX>For example, suppose you want to also include a link to a particular 
file for each atom cell. The output should look something like this: </P><PRE><CODE>&lt;td&gt;
  &lt;font face="Times, serif" color="blue" size="2"&gt;
    &lt;b&gt;
      &lt;a href="atomic_number.html"&gt;52&lt;/a&gt;
    &lt;/b&gt;
  &lt;/font&gt;
&lt;/td&gt;
</CODE></PRE>
<P class=GX>The trick is that the value of the <CODE>href</CODE> attribute has 
to be passed in from the point where the template is invoked because it changes 
for each separate invocation of the template. For example, atomic weights will 
have to be formatted like this: </P><PRE><CODE>&lt;td&gt;
  &lt;font face="Times, serif" color="blue" size="2"&gt;
    &lt;b&gt;
      &lt;a href="atomic_weight.html"&gt;4.0026&lt;/a&gt;
    &lt;/b&gt;
  &lt;/font&gt;
&lt;/td&gt;
</CODE></PRE>
<P class=GX>The template that supports this looks like this:</P><PRE><CODE>&lt;xsl:template name="ATOM_CELL"&gt;
  &lt;xsl:param name="file"&gt;index.html&lt;/xsl:param&gt;
  &lt;td&gt;
    &lt;font face="Times, serif" color="blue" size="2"&gt;
      &lt;b&gt;
        &lt;a href="{$file}"&gt;&lt;xsl:value-of select="."/&gt;&lt;/a&gt;
      &lt;/b&gt;
    &lt;/font&gt;
  &lt;/td&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>The <CODE>name</CODE> attribute of the <CODE>xsl:param</CODE> 
element gives the parameter a name (important if there are multiple arguments) 
and the contents of the <CODE>xsl:param</CODE> element supplies a default value 
for this parameter to be used if the invocation doesn't provide a value. (This 
can also be given as a string expression by using a <CODE>select</CODE> 
attribute.) </P>
<P class=GX>When this template is called, an <CODE>xsl:with-param</CODE> child 
of the <CODE>xsl:call-template</CODE> element provides the value of the 
parameter using its <CODE>name</CODE> attribute to identify the parameter and 
its contents to provide a value for the parameter. For example: </P><PRE><CODE>&lt;xsl:template match="ATOMIC_NUMBER"&gt;
  &lt;xsl:call-template name="ATOM_CELL"&gt;
    &lt;xsl:with-param 
                name="file"&gt;atomic_number.html&lt;/xsl:with-param&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>Again, this is a simple example. However, much more complex named 
templates exist. For instance, you could define header and footer templates for 
pages on a Web site for importing by many different style sheets, each of which 
would only have to change a few parameters for the name of the page author, the 
title of the page, and the copyright date. </P>
<H2><A name=d1e8886>Stripping and Preserving White Space</A></H2>
<P class=GX>You may have noticed that most of the examples of output have been 
formatted a little strangely. The reason the examples appeared strange is that 
the source document needed to break long elements across multiple lines to fit 
between the margins of this book. Unfortunately, the extra white space added to 
the input document carried over into the output document. For a computer, the 
details of insignificant white space aren't important, but for a person they can 
be distracting. </P>
<P class=GX>The default behavior for text nodes read from the input document, 
such as the content of an <CODE>ATOMIC_NUMBER</CODE> or <CODE>DENSITY</CODE> 
element, is to preserve all white space. A typical <CODE>DENSITY</CODE> element 
looks like this: </P><PRE><CODE>    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
</CODE></PRE>
<P class=GX>When its value is taken the leading and trailing white space is 
included, like this, even though it's really only there to help fit on this 
printed page and isn't at all significant: </P><PRE><CODE>      0.0000899
</CODE></PRE>
<P class=GX>You can use the <CODE>normalize-space()</CODE> function to strip the 
leading and trailing white space from this or any other string. For example, 
instead of writing <CODE>&lt;xsl:value-of select="DENSITY"/&gt;</CODE>, you 
would write <CODE>&lt;xsl:value-of 
select="normalize-space(DENSITY)"/&gt;</CODE>. </P>
<P class=GX>You can also automatically delete white-space only nodes in the 
input document by using <CODE>xsl:strip-space</CODE>. The <CODE>elements</CODE> 
attribute of this top-level element contains a list of elements from which text 
nodes that contain nothing but white space should be deleted. For example, this 
element says that nodes containing only white space should be stripped from 
<CODE>DENSITY</CODE>, <CODE>NAME</CODE>, <CODE>SYMBOL</CODE>, and 
<CODE>BOILING_POINT</CODE> elements: </P><PRE><CODE>&lt;xsl:strip-space elements="DENSITY NAME SYMBOL BOILING_POINT"/&gt;
</CODE></PRE>
<P class=GX>You can strip space-only nodes in all elements by using the 
<CODE>*</CODE> wildcard, like this: </P><PRE><CODE>&lt;xsl:strip-space elements="*"/&gt;
</CODE></PRE>
<P class=GX>There's also an <CODE>xsl:preserve-space</CODE> element with a 
similar syntax but opposite meaning. However, since preserving space is the 
default, this element isn’t much used. Its main purpose is to override 
<CODE>xsl:strip-space</CODE> elements imported from other style sheets or to 
specify a few elements where space is preserved when the default has been reset 
to stripping by <CODE>&lt;xsl:strip-space elements="*"/&gt;</CODE>. </P>
<P class=GX>White space only text nodes in the style sheet, as opposed to the 
input document, are another matter. They are stripped by default. If you want to 
preserve one, you attach an <CODE>xml:space</CODE> attribute with the value 
<CODE>preserve</CODE> to its parent element or to another one of its ancestors. 
</P>
<P class=SBT 
style="FONT-WEIGHT: bold; MARGIN-LEFT: 0.5in; COLOR: #0000ff; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">Cross-Reference</P>
<P class=SBT 
style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in; FONT-FAMILY: Arial, Helvetica, sans">The 
<CODE>xml:space</CODE> attribute was discussed in Chapter 11. </P>
<P class=GX>Sometimes the easiest way to include significant white space in a 
style sheet is to wrap it in an <CODE>xsl:text</CODE> element. Space inside an 
<CODE>xsl:text</CODE> element is treated literally and never stripped. </P>
<H2><A name=d1e9006>Making Choices</A></H2>
<P class=GX>XSLT provides two elements that allow you to change the output based 
on the input. The <CODE>xsl:if</CODE> element either does or does not output a 
given fragment of XML depending on what patterns are present in the input. The 
<CODE>xsl:choose</CODE> element picks one of several possible XML fragments, 
depending on what patterns are present in the input. Most of what you can do 
with <CODE>xsl:if</CODE> and <CODE>xsl:choose</CODE> can also be done by a 
suitable application of templates. However, sometimes the solution with 
<CODE>xsl:if</CODE> or <CODE>xsl:choose</CODE> is simpler and more obvious. </P>
<H3>xsl:if</H3>
<P class=GX>The <CODE>xsl:if</CODE> element provides a simple facility for 
changing the output based on a pattern. The <CODE>test</CODE> attribute of 
<CODE>xsl:if</CODE> contains an expression that evaluates to a boolean. If the 
expression is true, the contents of the <CODE>xsl:if</CODE> element are output. 
Otherwise, they're not. For example, this template writes out the names of all 
<CODE>ATOM</CODE> elements. A comma and a space is added after all except the 
last element in the list. </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:value-of select="NAME"/&gt;
  &lt;xsl:if test="position()!=last()"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<P class=GX>This ensures that the list looks like "Hydrogen, Helium" and not 
"Hydrogen, Helium, ".</P>
<P class=GX>There are no <CODE>xsl:else</CODE> or <CODE>xsl:else-if</CODE> 
elements. The <CODE>xsl:choose</CODE> element provides this functionality. </P>
<H3>xsl:choose</H3>
<P class=GX>The <CODE>xsl:choose</CODE> element selects one of several possible 
outputs depending on several possible conditions. Each condition and its 
associated output template is provided by an <CODE>xsl:when</CODE> child 
element. The <CODE>test</CODE> attribute of the <CODE>xsl:when</CODE> element is 
an XPath expression with a boolean value. If multiple conditions are true, only 
the first true one is instantiated. If none of the <CODE>xsl:when</CODE> 
elements are true, the <CODE>xsl:otherwise</CODE> child element is instantiated. 
For example, this rule changes the color of the output based on whether the 
<CODE>STATE</CODE> attribute of the <CODE>ATOM</CODE> element is 
<CODE>SOLID</CODE>, <CODE>LIQUID</CODE>, or <CODE>GAS</CODE>: </P><PRE><CODE>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@STATE='SOLID'"&gt;
      &lt;P style="color: black"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@STATE='LIQUID'"&gt;
      &lt;P style="color: blue"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@STATE='GAS'"&gt;
      &lt;P style="color: red"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;P style="color: green"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</CODE></PRE>
<H2><A name=d1e9189>Merging Multiple Style Sheets</A></H2>
<P class=GX>A single XML document may use many different markup vocabularies 
described in many different DTDs. You may wish to use different standard style 
sheets for those different vocabularies. However, you'll also want style rules 
for particular documents as well. The <CODE>xsl:import</CODE> and 
<CODE>xsl:include</CODE> elements enable you to merge multiple style sheets so 
that you can organize and reuse style sheets for different vocabularies and 
purposes. </P>
<H3>Importing with xsl:import</H3>
<P class=GX>The <CODE>xsl:import</CODE> element is a top-level element whose 
<CODE>href</CODE> attribute provides the URI of a style sheet to import. All 
<CODE>xsl:import</CODE> elements must appear before any other top-level element 
in the <CODE>xsl:stylesheet</CODE> root element. For example, these 
<CODE>xsl:import</CODE> elements import the style sheets genealogy.xsl and 
standards.xsl. </P><PRE><CODE>&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="genealogy.xsl"/&gt;
  &lt;xsl:import href="standards.xsl"/&gt;
  &lt;!-- other child elements follow --&gt;
&lt;/xsl:stylesheet&gt;
</CODE></PRE>
<P class=GX>Rules in the imported style sheets may conflict with rules in the 
importing style sheet. If so, rules in the importing style sheet take 
precedence. If two rules in different imported style sheets conflict, then the 
rule in the last style sheet imported (standards.xsl above) takes precedence. 
</P>
<P class=GX>The <CODE>xsl:apply-imports</CODE> element is a slight variant of 
<CODE>xsl:apply-templates</CODE> that only uses imported rules. It does not use 
any rules from the importing style sheet. This allows access to imported rules 
that would otherwise be overridden by rules in the importing style sheet. Other 
than the name, it has identical syntax to <CODE>xsl:apply-templates</CODE>. The 
only behavioral difference is that it only matches template rules in imported 
style sheets. </P>
<H3>Inclusion with xsl:include</H3>
<P class=GX>The <CODE>xsl:include</CODE> element is a top-level element that 
copies another style sheet into the current style sheet at the point where it 
occurs. (More precisely, it copies the contents of the 
<CODE>xsl-stylesheet</CODE> or <CODE>xsl:transform</CODE> element in the remote 
document into the current document.) Its <CODE>href</CODE> attribute provides 
the URI of the style sheet to include. An <CODE>xsl:include</CODE> element can 
occur anywhere at the top level after the last <CODE>xsl:import</CODE> element. 
</P>
<P class=GX>Unlike rules included by <CODE>xsl:import</CODE> elements, rules 
included by <CODE>xsl:include</CODE> elements have the same precedence in the 
including style sheet that they would have if they were copied and pasted from 
one style sheet to the other. As far as the XSLT processor is concerned, there 
is no difference between an included rule and a rule that's physically present. 
</P>
<H3>Embedding with xsl:stylesheet</H3>
<P class=GX>You can directly include an XSLT style sheet in the XML document it 
applies to. I don't recommend this in practice, and browsers and XSLT processors 
are not required to support it. Nonetheless, a few do. To use this, the 
<CODE>xsl:stylesheet</CODE> element must appear as a child of the document 
element, rather than as a root element itself. It would have an <CODE>id</CODE> 
attribute giving it a unique name, and this <CODE>id</CODE> attribute would 
appear as the value of the <CODE>href</CODE> attribute in the 
<CODE>xml-stylesheet</CODE> processing instruction, following the fragment 
identifier separator <CODE>#</CODE>. Listing 17-21 demonstrates. </P>
<P style="FONT-WEIGHT: bold">Listing 17-21: An XSLT style sheet embedded in an 
XML document </P><PRE><CODE>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xml" href="#id(mystyle)"?&gt;
&lt;PERIODIC_TABLE&gt;
  &lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    id="mystyle"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;P&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:template&gt;
    &lt;!--Don't display the style sheet itself
       or its descendants--&gt;
    &lt;xsl:template match="xsl:stylesheet"/&gt;
  &lt;/xsl:stylesheet&gt;
  &lt;ATOM&gt;
    &lt;NAME&gt;Actinium&lt;/NAME&gt;
    &lt;ATOMIC_WEIGHT&gt;227&lt;/ATOMIC_WEIGHT&gt;
    &lt;ATOMIC_NUMBER&gt;89&lt;/ATOMIC_NUMBER&gt;
    &lt;OXIDATION_STATES&gt;3&lt;/OXIDATION_STATES&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;3470&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;1324&lt;/MELTING_POINT&gt;
    &lt;SYMBOL&gt;Ac&lt;/SYMBOL&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;&lt;!-- At 300K --&gt;
      10.07
    &lt;/DENSITY&gt;
    &lt;ELECTRONEGATIVITY&gt;1.1&lt;/ELECTRONEGATIVITY&gt;
    &lt;ATOMIC_RADIUS UNITS="Angstroms"&gt;1.88&lt;/ATOMIC_RADIUS&gt;
  &lt;/ATOM&gt;
&lt;/PERIODIC_TABLE&gt;
</CODE></PRE>
<H2><A name=d1e9432>Output Methods</A></H2>
<P class=GX>Most of the examples in this chapter have focused on transforming 
XML into well-formed HTML. However, most XSLT processors actually support three 
different output methods: </P>
<UL>
  <LI>XML 
  <LI>HTML 
  <LI>Text </LI></UL>
<P class=GX>The XSLT processor behaves differently depending on which of these 
output methods it uses. The XML format is the default and in many ways the 
simplest. The output is mostly exactly what you request in your style sheet. 
Because well-formed XML does not permit raw less-than signs and ampersands, if 
you use a character reference such as <CODE>&amp;#60;</CODE> or the entity 
reference <CODE>&amp;lt;</CODE> to insert the <CODE>&lt;</CODE> character, the 
formatter will output <CODE>&amp;lt;</CODE> or perhaps <CODE>&amp;#60;</CODE>. 
If you use a character reference such as <CODE>&amp;#38;</CODE> or the entity 
reference <CODE>&amp;amp;</CODE> to insert the <CODE>&amp;</CODE> character, the 
formatter will insert <CODE>&amp;amp;</CODE> or perhaps <CODE>&amp;#38;</CODE>. 
There are ways to disable this escaping, though, as you'll see later. </P>
<P class=GX>The HTML output method is designed to output standard HTML 4.0. This 
is not the well-formed HTML used in this book, but rather traditional HTML in 
which empty tags look like <CODE>&lt;HR&gt;</CODE> and <CODE>&lt;IMG&gt;</CODE> 
instead of <CODE>&lt;HR/&gt;</CODE> and <CODE>&lt;IMG/&gt;</CODE>, processing 
instructions are terminated with a <CODE>&gt;</CODE> instead of 
<CODE>?&gt;</CODE>, and <CODE>&lt;</CODE> signs used in JavaScript are not 
converted to <CODE>&amp;lt;</CODE>. This makes it much easier to output HTML 
that works across many browsers and platforms without odd effects such as double 
lines where a single line is expected or other detritus caused by forcing HTML 
into the XML mold. The HTML output method is automatically selected when the 
formatter notices that the root output element is <CODE>html</CODE>, 
<CODE>HTML</CODE>, <CODE>HtMl</CODE>, or any other combination of case that 
still spells Hypertext Markup Language. </P>
<P class=GX>The final output method is pure text. The text output method 
operates by first forming a full result tree as per the XML output method, but 
then only outputting the string value of that tree. This is useful for 
transforming to non-XML formats such as RTF or TeX. The primary benefit of the 
text output format is that less than signs are not converted to 
<CODE>&amp;lt;</CODE> or <CODE>&amp;#60;</CODE> and ampersands are not converted 
to <CODE>&amp;amp;</CODE> or <CODE>&amp;#38;</CODE>. This allows you to output 
effectively arbitrary text. </P>
<H3>xsl:output</H3>
<P class=GX>By default an XSLT processor will use the XML output method, unless 
it recognizes the output root element as <CODE>HTML</CODE>, in which case it 
uses the HTML output method. You can change this by using a top-level 
<CODE>xsl:output</CODE> element. The <CODE>method</CODE> attribute of the 
<CODE>xsl:output</CODE> element specifies which output method to use and 
normally has one of these three values: </P>
<UL>
  <LI><CODE>xml</CODE> 
  <LI><CODE>htm</CODE>l 
  <LI><CODE>text</CODE> </LI></UL>
<P class=GX>Formatting engines may support other values as well, but so far none 
do. For example, to specify that you want pure well-formed HTML as output, with 
all the empty tags properly indicated, all less than signs escaped, and so 
forth, you would use this <CODE>xsl:output</CODE> element at the top level of 
your style sheet: </P><PRE><CODE>&lt;xsl:output method="xml"/&gt;
</CODE></PRE>
<P class=GX>To indicate that you want regular HTML output even though you aren't 
using an <CODE>html</CODE> root element, you'd put this <CODE>xsl:output</CODE> 
element at the top level of your style sheet: </P><PRE><CODE>&lt;xsl:output method="html"/&gt;
</CODE></PRE>
<P class=GX>The <CODE>xsl:output</CODE> element also has a number of other 
allowed attributes that modify how XML is output. These allow you to change the 
prolog of the document, how the output is indented with insignificant white 
space, and which elements use <CODE>CDATA</CODE> sections rather than escaping 
<CODE>&lt;</CODE> and <CODE>&amp;</CODE> characters. </P>
<H3>XML Declaration</H3>
<P class=GX>Four attributes of <CODE>xsl:output</CODE> format the XML 
declaration used in your document. This assumes the output method is xml. These 
attributes are: </P>
<UL>
  <LI><CODE>omit-xml-declaration</CODE> 
  <LI><CODE>version</CODE> 
  <LI><CODE>encoding</CODE> 
  <LI><CODE>standalone</CODE> </LI></UL>
<P class=GX>The <CODE>omit-xml-declaration</CODE> attribute has the value 
<CODE>yes</CODE> or <CODE>no</CODE>. If <CODE>yes</CODE>, then an XML 
declaration is not included in the output document. If <CODE>no</CODE>, then it 
is. For example, to insert a very basic <CODE>&lt;?xml version="1.0"?&gt;</CODE> 
XML declaration in the output document you would use this 
<CODE>xsl:output</CODE> element at the top level of your style sheet: </P><PRE><CODE>&lt;xsl:output method="xml" omit-xml-declaration="no"/&gt;
</CODE></PRE>
<P class=GX>You could also include it as two separate <CODE>xsl:output</CODE> 
elements like this: </P><PRE><CODE>&lt;xsl:output method="xml"/&gt;
&lt;xsl:output omit-xml-declaration="no"/&gt;
</CODE></PRE>
<P class=GX>The default value of the <CODE>version</CODE> attribute of the XML 
declaration is 1.0. Currently, that's the only value allowed. If at some point 
in the future that changes, then the <CODE>version</CODE> attribute of 
<CODE>xsl:output</CODE> will allow you to change the version used in the XML 
declaration. For example, </P><PRE><CODE>&lt;xsl:output version="1.1"/&gt;
</CODE></PRE>
<P class=GX>You can set the <CODE>standalone</CODE> attribute of the XML 
declaration to the value <CODE>yes</CODE> or <CODE>no</CODE> using the 
<CODE>standalone</CODE> attribute of the <CODE>xsl:output</CODE> element. For 
example, this <CODE>xsl:output</CODE> element would insert the XML declaration 
<CODE>&lt;?xml version="1.0" standalone="yes"?&gt;</CODE>: </P><PRE><CODE>&lt;xsl:output method="xml"
            omit-xml-declaration="no" standalone="yes"/&gt;
</CODE></PRE>
<P class=GX>The final possible piece of an XML declaration is the 
<CODE>encoding</CODE> declaration. As you probably guessed this can be set with 
the encoding attribute of the <CODE>xsl:output</CODE> element. The value can be 
any legal encoding name registered with the Internet Assigned Numbers Authority 
as discussed in Chapter 7. For example, to insert the XML declaration 
<CODE>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</CODE>, you'd use this 
<CODE>xsl:output</CODE> element: </P><PRE><CODE>&lt;xsl:output method="xml"
          omit-xml-declaration="no" encoding="ISO-8859-1"/&gt;
</CODE></PRE>
<P class=GX>This also changes the encoding the XSLT processor uses for the 
output document from its default UTF-8. However, not all processors support all 
possible encodings. Those written in Java are likely to support the most 
encodings because Java's rich class library makes it almost trivial to support 
several dozen popular encodings. </P>
<H3>Document type declaration</H3>
<P class=GX>XSLT does not provide any elements for building an internal DTD 
subset for the output document with <CODE>&lt;!ELEMENT&gt;</CODE>, 
<CODE>&lt;!ATTLIST&gt;</CODE>, <CODE>&lt;!ENTITY&gt;</CODE>, and 
<CODE>&lt;!NOTATION&gt;</CODE> declarations. However, it does provide two 
attributes of the <CODE>xsl:output</CODE> element you can use to include a 
<CODE>DOCTYPE</CODE> declaration that points to an external DTD. These are 
<CODE>doctype-system</CODE> and <CODE>doctype-public</CODE>. The first inserts a 
<CODE>SYSTEM</CODE> identifier for the DTD; the second a <CODE>PUBLIC</CODE> 
identifier. For example, suppose you want this <CODE>DOCTYPE</CODE> declaration 
in your output document: </P><PRE><CODE>&lt;!DOCTYPE PERIODIC_TABLE SYSTEM "chemistry.dtd"&gt;
</CODE></PRE>
<P class=GX>Then you would use this <CODE>xsl:output</CODE> element at the top 
level of your style sheet: </P><PRE><CODE>&lt;xsl:output doctype-system="chemistry.dtd"/&gt;
</CODE></PRE>
<P class=GX>The XSLT processor determines the proper root element for the 
document type declaration by looking at the root element of the output tree. 
Using a full URL instead of a relative URL is equally easy: </P><PRE><CODE>&lt;xsl:output
  doctype-system="http://www.mysite.com/chemistry.dtd"/&gt;
</CODE></PRE>
<P class=GX>On the other hand, suppose you want this <CODE>DOCTYPE</CODE> 
declaration in your output document: </P><PRE><CODE>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
         "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;
</CODE></PRE>
<P class=GX>Then you would use both <CODE>doctype-system</CODE> and 
<CODE>doctype-public</CODE> attributes so your <CODE>DOCTYPE</CODE> declaration 
will have both a <CODE>PUBLIC</CODE> and a <CODE>SYSTEM</CODE> identifier. For 
example, </P><PRE><CODE>&lt;xsl:output
  doctype-system="http://www.w3.org/TR/REC-html40/loose.dtd"
  doctype-public="-//W3C//DTD HTML 4.0 Transitional//EN"/&gt;
</CODE></PRE>
<H3>Indentation</H3>
<P class=GX>The indentation of most of the output examples in this chapter has 
been more than a little flaky. It's certainly not as neat as the carefully 
hand-coded indentation of the input documents. However, if white space isn't 
particularly significant in your output document, you can change this and ask 
the formatter for "pretty printed" XML with the nesting of different elements 
indicated by the indentation. This is accomplished by the <CODE>indent</CODE> 
attribute of the <CODE>xsl:output</CODE> element. If this attribute has the 
value <CODE>yes</CODE> (the default is <CODE>no</CODE>), then the processor is 
allowed (but not required) to insert (but not remove) extra white space into the 
output to try to "pretty print" the output. This may include indentation and 
line breaks. For example, </P><PRE><CODE>&lt;xsl:output indent="yes"/&gt;
</CODE></PRE>
<P class=GX>You cannot, however, specify how much you want each level indented 
(for example, by two spaces or one tab). That's up to the formatter. Together, 
the <CODE>xsl:strip-space</CODE> and the <CODE>indent</CODE> attribute of the 
<CODE>xsl:output</CODE> element allow you to produce output that's almost as 
attractive as the most painstakingly hand-crafted XML. </P>
<H3>CDATA sections</H3>
<P class=GX>Standard XSLT does not allow you to insert CDATA sections at 
arbitrary locations in XML documents produced by XSL transformations. However, 
you can specify that the text contents of a particular element be placed in a 
<CODE>CDATA</CODE> section. In this case the <CODE>&lt;</CODE> and 
<CODE>&amp;</CODE> symbols are not encoded as <CODE>&amp;lt;</CODE> and 
<CODE>&amp;amp;</CODE> as they would normally be. To do this, place the name of 
the element whose text contents should be wrapped in CDATA delimiters in the 
<CODE>cdata-section-elements</CODE> attribute of the <CODE>xsl:output</CODE> 
element. For example, this <CODE>xsl:output</CODE> element says that the 
contents of the <CODE>SCRIPT</CODE> element should be wrapped in a CDATA 
section: </P><PRE><CODE>&lt;xsl:output cdata-section-elements="SCRIPT"/&gt;
</CODE></PRE>
<P class=GX>You can enclose multiple names of elements whose text contents 
should be wrapped in CDATA delimiters in one <CODE>cdata-section-elements</CODE> 
attribute simply by separating the names with white space. For example, this 
<CODE>xsl:output</CODE> element says that the contents of both the 
<CODE>SCRIPT</CODE> and <CODE>CODE</CODE> elements should be wrapped in a CDATA 
section: </P><PRE><CODE>&lt;xsl:output cdata-section-elements="SCRIPT CODE"/&gt;
</CODE></PRE>
<P class=GX>Alternately, you can just use multiple <CODE>xsl:output</CODE> 
elements, each naming one element. For example: </P><PRE><CODE>&lt;xsl:output cdata-section-elements="SCRIPT"/&gt;
&lt;xsl:output cdata-section-elements="CODE"/&gt;
</CODE></PRE>
<H3>Media type</H3>
<P class=GX>One final <CODE>xsl:output</CODE> attribute specifies the MIME media 
type of the output document. This is <CODE>media-type</CODE>. Mostly this will 
have the value <CODE>text/xml</CODE>, but it might be <CODE>text/html</CODE> for 
the HTML output method, <CODE>text/plain</CODE> for the text output method, or 
even something else such as <CODE>text/rtf</CODE>. You should not specify a 
charset parameter for the media type. The formatting engine should determine 
this from the <CODE>encoding</CODE> attribute of the <CODE>xsl:output</CODE> 
element. For example, this <CODE>xsl:output</CODE> element specifies that the 
output encoding uses the text/rtf MIME type: </P><PRE><CODE>&lt;xsl:output media-type="text/rtf"/&gt;
</CODE></PRE>
<P class=GX>Depending on external context, this may determine the filename 
extension, the icon of the file, how an HTTP server handles the file, or 
something else. Then again, it might have no effect at all. The XSLT processor 
might ignore this request and output the same byte stream or XML tree regardless 
of media type. This is something that's important to the environment in which 
the XML document exists, but not so important to the XML document itself. </P>
<H2 class=sum-H>Summary</H2>
<P class=sum-X>In this chapter, you learned about XSL transformations. In 
particular, you learned that:</P>
<UL>
  <LI>The Extensible Stylesheet Language (XSL) comprises two separate XML 
  applications for transforming and formatting XML documents. 
  <LI>An XSL transformation applies rules to a tree read from an XML document to 
  transform it into an output tree written out as an XML document. 
  <LI>An XSL template rule is an <CODE>xsl:template</CODE> element with a 
  <CODE>match</CODE> attribute. Nodes in the input tree are compared against the 
  patterns of the <CODE>match</CODE> attributes of the different template 
  elements. When a match is found, the contents of the template are output. 
  <LI>The value of a node is a pure text (no markup) string containing the 
  contents of the node. This can be calculated by the <CODE>xsl:value-of</CODE> 
  element. 
  <LI>You can process multiple elements in two ways: the 
  <CODE>xsl:apply-templates</CODE> element and the <CODE>xsl:for each</CODE> 
  element. 
  <LI>The value of the <CODE>match</CODE> attribute of the 
  <CODE>xsl:template</CODE> element is a match pattern specifying which nodes 
  the template matches. 
  <LI>XPath expressions (or simply expressions) are a superset of match patterns 
  used by the <CODE>select</CODE> attribute of <CODE>xsl:apply-templates</CODE>, 
  <CODE>xsl:value-of</CODE>, <CODE>xsl:for-each</CODE>, 
  <CODE>xsl:copy-of</CODE>, <CODE>xsl:variable</CODE>, <CODE>xsl:param</CODE>, 
  <CODE>xsl:with-param</CODE>, and <CODE>xsl:sort</CODE> elements. 
  <LI>Default rules apply templates to element nodes and take the value of text 
  nodes and attributes. 
  <LI>The <CODE>xsl:element</CODE>, <CODE>xsl:attribute</CODE>, 
  <CODE>xsl:processing-instruction</CODE>, <CODE>xsl:comment</CODE>, and 
  <CODE>xsl:text</CODE> elements output elements, attributes, processing 
  instructions, comments, and text calculated from data in the input document. 
  <LI>The <CODE>xsl:attribute-set</CODE> element defines a common group of 
  attributes that can be applied to multiple elements in different templates 
  with the <CODE>xsl:use-attribute-sets</CODE>. 
  <LI>The <CODE>xsl:copy</CODE> element copies the current node from the input 
  into the output. 
  <LI>The <CODE>xsl:number</CODE> element inserts the number specified by its 
  <CODE>value</CODE> attribute into the output using a specified number format 
  given by the <CODE>format</CODE> attribute. 
  <LI>The <CODE>xsl:sort</CODE> element can reorder the input nodes before 
  copying them to the output. 
  <LI>Modes can apply different templates to the same element from different 
  locations in the style sheet. 
  <LI>The <CODE>xsl:variable</CODE> element defines named constants that can 
  clarify your code. 
  <LI>Named templates help you reuse common template code. 
  <LI>White space is maintained by default unless an 
  <CODE>xsl:strip-space</CODE> element or <CODE>xml:space</CODE> attribute says 
  otherwise. 
  <LI>The <CODE>xsl:if</CODE> element produces output if, and only if, its 
  <CODE>test</CODE> attribute is true. 
  <LI>The <CODE>xsl:choose</CODE> element outputs the template of the first one 
  of its <CODE>xsl:when</CODE> children whose <CODE>test</CODE> attribute is 
  true, or the template of its <CODE>xsl:otherwise</CODE> element if no 
  <CODE>xsl:when</CODE> element has a <CODE>true</CODE> <CODE>test</CODE> 
  attribute. 
  <LI>The <CODE>xsl:import</CODE> and <CODE>xsl:include</CODE> elements merge 
  rules from different style sheets. 
  <LI>The <CODE>xsl:stylesheet</CODE> element allows you to include a style 
  sheet directly in the document it applies to. 
  <LI>Various attributes of the <CODE>xsl:output</CODE> element allow you to 
  specify the output document's format, XML declaration, <A id=s shape=rect 
  name=s></A>document type declaration, indentation, encoding and MIME type. 
  </LI></UL>
<P class=sum-X>The next chapter takes up the second half of XSL: the formatting 
objects vocabulary. Formatting objects is an extremely powerful way of 
specifying the precise layout you want your pages to have. XSL transformations 
are used to transform an XML document into an XSL formatting object document. 
</P>
<HR>

<DIV style="TEXT-ALIGN: center">[ <A 
href="http://www.ibiblio.org/xml/books/index.html">Cafe con Leche</A> | <A 
href="http://www.ibiblio.org/xml/books/bible2/index.html">XML Bible Home 
Page</A> | Order from <A 
href="http://www.amazon.com/exec/obidos/ASIN/0764547607/ref=nosim/cafeaulaitA/">amazon.com</A> 
] </DIV>
<HR>
Copyright 2001 <A href="http://www.macfaq.com/personal.html">Elliotte Rusty 
Harold</A><BR><A 
href="mailto:elharo@metalab.unc.edu">elharo@metalab.unc.edu</A><BR>Last Modified 
November 5, 2001 </BODY></HTML>
